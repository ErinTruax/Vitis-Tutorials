
<table>
<tr>
<td align="center"><img src="https://www.xilinx.com/content/dam/xilinx/imgs/press/media-kits/corporate/xilinx-logo.png" width="30%"/>
</td>
</tr>
</table>
<p><a class="reference external" href="#Building-the-Design">Building the Design</a></p>
<p><a class="reference external" href="#Hardware-Design-Details">Hardware Design Details</a></p>
<p><a class="reference external" href="#Software-Design-Details">Software Design Details</a></p>
<p><a class="reference external" href="#Performance-Details">Performance Details</a></p>
<details>
<summary>Design Build</summary>
<h2>Design Build</h2>
<p>In this section, you will build and run the 2D-FFT design using the HLS/DSP implementation. You will compile the HLS/DSP design and integrate it into a larger system design (including the PL kernels and PS host application).</p>
<p>At the end of this section, the design flow will generate a new directory (called <code class="docutils literal notranslate"><span class="pre">build/</span></code>). Underneath are sub-directories named <code class="docutils literal notranslate"><span class="pre">fft2d_$(MAT_ROWS)x$(MAT_COLS)/x$(FFT_2D_INSTS)/</span></code> (<code class="docutils literal notranslate"><span class="pre">fft2d_1024x2048/x1/</span></code>, for example) depending on the value of the matrix dimensions (<code class="docutils literal notranslate"><span class="pre">${MAT_ROWS}</span></code>, <code class="docutils literal notranslate"><span class="pre">${MAT_COLS}</span></code>) and the number of instances (<code class="docutils literal notranslate"><span class="pre">$(FFT_2D_INSTS)</span></code>) chosen in the build. Each sub-directory contains the <code class="docutils literal notranslate"><span class="pre">hw_emu/</span></code> and/or <code class="docutils literal notranslate"><span class="pre">hw/</span></code> subfolders. These sub-folders contain a host app executable and the builds targeted to <code class="docutils literal notranslate"><span class="pre">hw</span></code> or <code class="docutils literal notranslate"><span class="pre">hw_emu</span></code> respectively. The <code class="docutils literal notranslate"><span class="pre">hw_emu/</span></code> sub-folder contains the build for hardware emulation. The <code class="docutils literal notranslate"><span class="pre">hw/</span></code> sub-folder contains the build for a hardware run on a VCK190 board.</p>
</details><details>
<summary>Make Steps</summary> </details>
<h2>Make Steps</h2>
<p>To run the following <code class="docutils literal notranslate"><span class="pre">make</span></code> steps (for example, <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">kernels</span></code>, <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">xclbin</span></code>, and so on), you must be in the <code class="docutils literal notranslate"><span class="pre">HLS/</span></code> folder. The following options can be specified in the <code class="docutils literal notranslate"><span class="pre">make</span></code> steps. Instructions for how to apply them are provided later in this section.</p>
<p><code class="docutils literal notranslate"><span class="pre">TARGET:</span></code> This option can be set to <code class="docutils literal notranslate"><span class="pre">hw</span></code> or <code class="docutils literal notranslate"><span class="pre">hw_emu</span></code> to build the design in the hardware or hardware emulation flow. The default is <code class="docutils literal notranslate"><span class="pre">hw_emu</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">FFT_2D_INSTS:</span></code> This option can be set to 1, 5, or 10 to build the design with the number of kernel instances. The default is <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">ITER_CNT:</span></code> The number of iterations the design is run. The default is <code class="docutils literal notranslate"><span class="pre">8</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">FFT_2D_PT:</span></code> FFT 2D point. Permissible values are <code class="docutils literal notranslate"><span class="pre">64</span></code>, <code class="docutils literal notranslate"><span class="pre">128</span></code>, <code class="docutils literal notranslate"><span class="pre">256</span></code>, <code class="docutils literal notranslate"><span class="pre">512</span></code>, and <code class="docutils literal notranslate"><span class="pre">2048</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">MAT_ROWS</span> <span class="pre">x</span> <span class="pre">MAT_COLS:</span></code> Dimensions of the matrix (number of rows in the input matrix x number of cols in the input matrix). Automatically configured as <code class="docutils literal notranslate"><span class="pre">FFT_2D_PT/2,</span> <span class="pre">FFT_2D_PT</span></code>. Permissible values are <code class="docutils literal notranslate"><span class="pre">32x64</span></code>, <code class="docutils literal notranslate"><span class="pre">64x128</span></code>, <code class="docutils literal notranslate"><span class="pre">128x256</span></code>, <code class="docutils literal notranslate"><span class="pre">256x512</span></code>, and <code class="docutils literal notranslate"><span class="pre">1024x2048</span></code>. The default is <code class="docutils literal notranslate"><span class="pre">1024x2048</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">EN_TRACE:</span></code> Flag to enable trace profiling. <code class="docutils literal notranslate"><span class="pre">0</span></code> is disabled and <code class="docutils literal notranslate"><span class="pre">1</span></code> is enabled. The default is <code class="docutils literal notranslate"><span class="pre">0</span></code> (disabled).</p>
<p>The Makefile uses the following directory references:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># Relative fft_2d directory
RELATIVE_PROJECT_DIR := ./

# Absolute fft_2d directory = &lt;user path&gt;/Tutorials/AI_Engine/fft_2d
PROJECT_REPO := $(shell readlink -f $(RELATIVE_PROJECT_DIR))

DESIGN_REPO  := $(PROJECT_REPO)/design
HOST_APP_SRC := $(DESIGN_REPO)/host_app_src
PL_SRC_REPO  := $(DESIGN_REPO)/pl_src
DIRECTIVES_REPO        := $(DESIGN_REPO)/directives
SYSTEM_CONFIGS_REPO    := $(DESIGN_REPO)/system_configs
PROFILING_CONFIGS_REPO := $(DESIGN_REPO)/profiling_configs
BASE_BLD_DIR     := $(PROJECT_REPO)/build
FFTPT_BLD_DIR    := $(BASE_BLD_DIR)/fft2d_$(MAT_ROWS)x$(MAT_COLS)
INSTS_BLD_DIR    := $(FFTPT_BLD_DIR)/x$(FFT_2D_INSTS)
BUILD_TARGET_DIR := $(INSTS_BLD_DIR)/$(TARGET)
</pre></div>
</div>
<details>
<summary>Build the Entire Design with a Single Command</summary></details>
<h2>Build the Entire Design with a Single Command</h2>
<p>If you are already familiar with the HLS and Vitis kernel compilation flows, you can build the entire design for each case of <code class="docutils literal notranslate"><span class="pre">FFT_2D_INSTS</span></code> with one command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make run <span class="o">(</span>default hardware emulation, <span class="m">1</span> instance, <span class="nv">iterations</span><span class="o">=</span><span class="m">8</span>, matrix dimentions <span class="nv">rows</span><span class="o">=</span><span class="m">1024</span> and <span class="nv">columns</span><span class="o">=</span><span class="m">2048</span>, no trace-profiling <span class="o">)</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make run <span class="nv">TARGET</span><span class="o">=</span>hw <span class="nv">FFT_2D_INSTS</span><span class="o">=</span><span class="m">5</span> <span class="nv">ITER_CNT</span><span class="o">=</span><span class="m">16</span> <span class="nv">EN_TRACE</span><span class="o">=</span><span class="m">1</span> <span class="nv">FFT_2D_PT</span><span class="o">=</span><span class="m">64</span> <span class="o">(</span>hardware, <span class="m">5</span> instances, <span class="m">16</span> iterations, <span class="nb">enable</span> trace profiling, matrix dimentions <span class="nv">rows</span><span class="o">=</span><span class="m">32</span> and <span class="nv">columns</span><span class="o">=</span><span class="m">64</span> <span class="o">)</span>
</pre></div>
</div>
<p>This command runs the <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">kernels</span></code>, <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">xclbin</span></code>, <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">application</span></code>, <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">package</span></code>, and <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">run_emu</span></code> steps for hardware emulation or to run on hardware (VCK190 board) depending on the <code class="docutils literal notranslate"><span class="pre">TARGET</span></code> you specify. The settings also apply to individual make steps listed below.</p>
<p>The generated files for each <code class="docutils literal notranslate"><span class="pre">FFT_2D_INSTS</span></code> are placed under an individual directory: <code class="docutils literal notranslate"><span class="pre">$(BUILD_TARGET_DIR)/</span></code>. Each <code class="docutils literal notranslate"><span class="pre">make</span></code> step to build the design is specified in the following sections. These sections also detail the options used and the location of input and output files in each case.</p>
<details>
<summary>make kernels: Compiling PL Kernels</summary> </details>
<h2>make kernels: Compile PL Kernels</h2>
<p>In this step, the Vitis compiler takes any V++ kernels (RTL or HLS C) in the PL region of the target platform (<code class="docutils literal notranslate"><span class="pre">xilinx_vck190_base_202110_1</span></code>) and the HLS kernels and compiles them into their respective XO files. The following commands compile the kernels (default <code class="docutils literal notranslate"><span class="pre">TARGET=hw_emu</span></code>, <code class="docutils literal notranslate"><span class="pre">FFT_2D_INSTS=1</span></code>, <code class="docutils literal notranslate"><span class="pre">ITER_CNT=8</span></code>, and <code class="docutils literal notranslate"><span class="pre">FFT_2D_PT=2048</span></code>).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">kernels</span>
</pre></div>
</div>
<p>The expanded command is as follows (for <code class="docutils literal notranslate"><span class="pre">fft_2d</span></code>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>mkdir -p $(BUILD_TARGET_DIR); \

cd $(BUILD_TARGET_DIR); \

v++ --target hw_emu --hls.pre_tcl $$(DIRECTIVES_REPO)/hls_pre.tcl \
   --hls.clock 500000000:fft_2d -D MAT_ROWS=1024 -D MAT_COLS=2048 \
   --platform xilinx_vck190_base_202110_1 --save-temps --temp_dir $(BUILD_TARGET_DIR)/_x \
   --verbose -g -c -k fft_2d $(DESIGN_REPO)/pl_src/fft_2d.cpp -o $(BUILD_TARGET_DIR)/fft_2d.hw_emu.xo
</pre></div>
</div>
<p>For <code class="docutils literal notranslate"><span class="pre">dma_hls</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>mkdir -p $(BUILD_TARGET_DIR); \

cd $(BUILD_TARGET_DIR); \

v++ --target hw_emu --hls.clock 250000000:dma_hls --platform xilinx_vck190_base_202110_1 \
   --save-temps --temp_dir $(BUILD_TARGET_DIR)/_x --verbose -g -c -k dma_hls \
   $(DESIGN_REPO)/pl_src/dma_hls.cpp -o $(BUILD_TARGET_DIR)/dma_hls.hw_emu.xo
</pre></div>
</div>
<p>See <a class="reference external" href="https://www.xilinx.com/html_docs/xilinx2021_1/vitis_doc/vitiscommandcompiler.html#wrj1504034328013">this page</a> for a detailed description of all Vitis compiler switches. The following table provides a summary of the switches used.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Switch</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>--target | -t [hw|hw_emu]</td>
<td>Specifies the build target.</td>
</tr>
<tr>
<td>--hls.pre_tcl \&lt;arg&gt;</td>
<td>Specifies a Tcl file containing Tcl commands for <code>vitis_hls</code> to source before running <code>csynth_design</code>. See <a href="https://www.xilinx.com/html_docs/xilinx2021_1/vitis_doc/vitiscommandcompiler.html?hl=hls.pre_tcl#mcj1568640526180">this page</a> for details about HLS options.</td>
</tr>
<tr>
<td>--platform | -f</td>
<td>Specifies the name of a supported acceleration platform as specified by the $PLATFORM_REPO_PATHS environment variable or the full path to the platform XPFM file.</td>
</tr>
<tr>
<td>--save-temps | -s</td>
<td>Directs the Vitis compiler command to save intermediate files/directories created during the compilation and link process. Use the <code>--temp_dir</code> option to specify a location to write the intermediate files to.</td>
</tr>
<tr>
<td>--temp_dir <string></string></td>
<td>This allows you to manage the location where the tool writes temporary files created during the build process. The temporary results are written by the Vitis compiler, and then removed, unless the <code>--save-temps</code> option is also specified.</td>
</tr>
<tr>
<td>--verbose</td>
<td>Display verbose/debug information.</td>
</tr>
<tr>
<td>--compile | -c</td>
<td>Required for compilation to generate XO files from kernel source files.</td>
</tr>
<tr>
<td>--kernel \&lt;arg&gt;|-k \&lt;arg&gt;</td>
<td>Compile only the specified kernel from the input file. Only one -k option is allowed per Vitis compiler command.</td>
</tr>
<tr>
<td>-D | --define  \&lt;Macro Name&gt;=\&lt;value&gt;</td>
<td>Defines Macros for the compiler.</td>
</tr>
<tr>
<td>--output | -o</td>
<td>Specifies the name of the output file generated by the V++ command. The DMA HLS kernels output should be XO.</td>
</tr>
</tbody>
</table><table border="1" class="docutils">
<thead>
<tr>
<th>Input</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>$(PL_SRC_REPO)/fft_2d.cpp</td>
<td>Defines the fft_2d PL kernel.</td>
</tr>
<tr>
<td>$(PL_SRC_REPO)/dma_hls.cpp</td>
<td>Defines the data mover PL kernel.</td>
</tr>
</tbody>
</table><table border="1" class="docutils">
<thead>
<tr>
<th>Output</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>$(BUILD_TARGET_DIR)/dma_hls.hw_emu.xo</td>
<td>The data mover kernel object file.</td>
</tr>
</tbody>
</table><details>
<summary>make xclbin: Using the Vitis Tools to Link HLS Kernels with the Platform</summary> </details>
<h2>make xclbin: Using the Vitis Tools to Link HLS Kernels with the Platform</h2>
<p>After the HLS kernels have been compiled, you can use the Vitis compiler to link them with the platform to generate an XCLBIN file.</p>
<p>The Vitis tools allow you to integrate the HLS kernels into an existing extensible platform. This is an automated step from a software developer perspective where the platform chosen is provided by the hardware designer (or you can opt to use one of the many extensible base platforms provided by Xilinx and the Vitis tools build the hardware design and integrate the HLS kernels into the design).</p>
<p>To test this feature in this tutorial, use the base VCK190 platform to build the design.</p>
<p>The command to run this step is shown as follows (default <code class="docutils literal notranslate"><span class="pre">TARGET=hw_emu</span></code>, <code class="docutils literal notranslate"><span class="pre">FFT_2D_INSTS=1</span></code>, <code class="docutils literal notranslate"><span class="pre">ITER_CNT=8</span></code>, <code class="docutils literal notranslate"><span class="pre">EN_TRACE=0</span></code>, <code class="docutils literal notranslate"><span class="pre">FFT_2D_PT=2048</span></code>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">xclbin</span>
</pre></div>
</div>
<p>The expanded command is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>cd $(BUILD_TARGET_DIR);	\

v++ -l --platform xilinx_vck190_base_202110_1 --save-temps --temp_dir $(BUILD_TARGET_DIR)/_x \
   --verbose -g --clock.freqHz 500000000:fft_2d_0 --clock.freqHz 250000000:dma_hls_0 --clock.defaultTolerance 0.001 \
   --advanced.param compiler.userPostSysLinkOverlayTcl=$(DIRECTIVES_REPO)/cdc_async.tcl \
   --config $(SYSTEM_CONFIGS_REPO)/x1.cfg --vivado.prop fileset.sim_1.xsim.simulate.log_all_signals=true \
   --vivado.prop run.synth_1.{STEPS.SYNTH_DESIGN.ARGS.CONTROL_SET_OPT_THRESHOLD}={16} \
   --vivado.prop run.impl_1.{strategy}={Performance_NetDelay_low} \
   --vivado.prop run.impl_1.{STEPS.OPT_DESIGN.ARGS.DIRECTIVE}={Explore} \
   -t hw_emu -o $(BUILD_TARGET_DIR)/vck190_dsp_fft_2d.hw_emu.xclbin $(BUILD_TARGET_DIR)/fft_2d.hw_emu.xo \
   $(BUILD_TARGET_DIR)/dma_hls.hw_emu.xo
</pre></div>
</div>
<p>The above <code class="docutils literal notranslate"><span class="pre">vivado.prop</span></code> settings are for every variation except for the 10-instance variation for 256 x 512 and 1024 x 2048. The settings for these dimensions are given in the following examples.</p>
<p>For the 256 x 512 10-instance design:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   <span class="o">--</span><span class="n">vivado</span><span class="o">.</span><span class="n">prop</span> <span class="n">run</span><span class="o">.</span><span class="n">synth_1</span><span class="o">.</span><span class="p">{</span><span class="n">STEPS</span><span class="o">.</span><span class="n">SYNTH_DESIGN</span><span class="o">.</span><span class="n">ARGS</span><span class="o">.</span><span class="n">CONTROL_SET_OPT_THRESHOLD</span><span class="p">}</span><span class="o">=</span><span class="p">{</span><span class="mi">16</span><span class="p">}</span>
   <span class="o">--</span><span class="n">vivado</span><span class="o">.</span><span class="n">prop</span> <span class="n">run</span><span class="o">.</span><span class="n">impl_1</span><span class="o">.</span><span class="p">{</span><span class="n">strategy</span><span class="p">}</span><span class="o">=</span><span class="p">{</span><span class="n">Performance_HighUtilSLRs</span><span class="p">}</span>
   <span class="o">--</span><span class="n">vivado</span><span class="o">.</span><span class="n">prop</span> <span class="n">run</span><span class="o">.</span><span class="n">impl_1</span><span class="o">.</span><span class="p">{</span><span class="n">STEPS</span><span class="o">.</span><span class="n">OPT_DESIGN</span><span class="o">.</span><span class="n">ARGS</span><span class="o">.</span><span class="n">DIRECTIVE</span><span class="p">}</span><span class="o">=</span><span class="p">{</span><span class="n">Explore</span><span class="p">}</span>
   <span class="o">--</span><span class="n">vivado</span><span class="o">.</span><span class="n">prop</span> <span class="n">run</span><span class="o">.</span><span class="n">impl_1</span><span class="o">.</span><span class="p">{</span><span class="n">STEPS</span><span class="o">.</span><span class="n">PHYS_OPT_DESIGN</span><span class="o">.</span><span class="n">ARGS</span><span class="o">.</span><span class="n">DIRECTIVE</span><span class="p">}</span><span class="o">=</span><span class="p">{</span><span class="n">AggressiveExplore</span><span class="p">}</span>
   <span class="o">--</span><span class="n">vivado</span><span class="o">.</span><span class="n">prop</span> <span class="n">run</span><span class="o">.</span><span class="n">impl_1</span><span class="o">.</span><span class="p">{</span><span class="n">STEPS</span><span class="o">.</span><span class="n">ROUTE_DESIGN</span><span class="o">.</span><span class="n">ARGS</span><span class="o">.</span><span class="n">DIRECTIVE</span><span class="p">}</span><span class="o">=</span><span class="p">{</span><span class="n">AggressiveExplore</span><span class="p">}</span>
</pre></div>
</div>
<p>For the 1024 x 2048 10-instance design:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   <span class="o">--</span><span class="n">vivado</span><span class="o">.</span><span class="n">prop</span> <span class="n">run</span><span class="o">.</span><span class="n">synth_1</span><span class="o">.</span><span class="p">{</span><span class="n">STEPS</span><span class="o">.</span><span class="n">SYNTH_DESIGN</span><span class="o">.</span><span class="n">ARGS</span><span class="o">.</span><span class="n">CONTROL_SET_OPT_THRESHOLD</span><span class="p">}</span><span class="o">=</span><span class="p">{</span><span class="mi">16</span><span class="p">}</span>
   <span class="o">--</span><span class="n">vivado</span><span class="o">.</span><span class="n">prop</span> <span class="n">run</span><span class="o">.</span><span class="n">impl_1</span><span class="o">.</span><span class="p">{</span><span class="n">strategy</span><span class="p">}</span><span class="o">=</span><span class="p">{</span><span class="n">Performance_HighUtilSLRs</span><span class="p">}</span>
   <span class="o">--</span><span class="n">vivado</span><span class="o">.</span><span class="n">prop</span> <span class="n">run</span><span class="o">.</span><span class="n">impl_1</span><span class="o">.</span><span class="p">{</span><span class="n">STEPS</span><span class="o">.</span><span class="n">OPT_DESIGN</span><span class="o">.</span><span class="n">ARGS</span><span class="o">.</span><span class="n">DIRECTIVE</span><span class="p">}</span><span class="o">=</span><span class="p">{</span><span class="n">AddRemap</span><span class="p">}</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">EN_TRACE</span></code> is enabled, the following Vitis compiler flags are also set:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   <span class="o">--</span><span class="n">profile</span><span class="o">.</span><span class="n">data</span> <span class="n">dma_hls</span><span class="p">:</span><span class="nb">all</span><span class="p">:</span><span class="nb">all</span> <span class="ow">or</span> <span class="n">profile</span><span class="o">.</span><span class="n">data</span> <span class="n">dma_hls</span><span class="p">:</span><span class="nb">all</span><span class="p">:</span><span class="n">strmInp_from_colwiseFFT</span> <span class="p">(</span><span class="k">for</span> <span class="n">higher</span> <span class="n">instances</span><span class="p">)</span> \
   <span class="o">--</span><span class="n">profile</span><span class="o">.</span><span class="n">trace_memory</span> <span class="n">DDR</span>
</pre></div>
</div>
<p>For higher values of <code class="docutils literal notranslate"><span class="pre">FFT_2D_INSTS</span></code>, only the <code class="docutils literal notranslate"><span class="pre">strmInp_from_colwiseFFT</span></code> port is profiled to avoid too much data.</p>
<p>See <a class="reference external" href="https://www.xilinx.com/html_docs/xilinx2021_1/vitis_doc/buildingdevicebinary.html#mjs1528399150499">this page</a> for a detailed description of Vitis linking options. The following table provides a summary of the switches used.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Switch</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>--platform | -f</td>
<td>Specifies the name of a supported acceleration platform as specified by the $PLATFORM_REPO_PATHS environment variable or the full path to the platform XPFM file.</td>
</tr>
<tr>
<td>--save-temps | -s</td>
<td>Directs the V++ command to save intermediate files/directories created during the compilation and link process. Use the <code>--temp_dir</code> option to specify a location to write the intermediate files to.</td>
</tr>
<tr>
<td>--temp_dir <string></string></td>
<td>This allows you to manage the location where the tool writes temporary files created during the build process. The temporary results are written by the Vitis compiler, and then removed, unless the <code>--save-temps</code> option is also specified.</td>
</tr>
<tr>
<td>--verbose</td>
<td>Display verbose/debug information.</td>
</tr>
<tr>
<td>--output | -o</td>
<td>Specifies the name of the output file generated by the V++ command. In this design the outputs of the HLS/DSP kernels with their interfacing with the PL kernels are in XO files.</td>
</tr>
<tr>
<td>--vivado.prop \&lt;arg&gt;</td>
<td>Specifies properties for the Vivado Design Suite to be used during synthesis and implementation of the FPGA binary (xclbin). See <a href="https://www.xilinx.com/html_docs/xilinx2021_1/vitis_doc/vitiscommandcompiler.html#pbx1568640588680">this page</a> for detailed Vivado options.</td>
</tr>
<tr>
<td>--profile.data [<kernel_name>|all]:[<cu_name>|all]:[<interface_name>|all](:[counters|all])</interface_name></cu_name></kernel_name></td>
<td>Enables monitoring of data ports through the monitor IPs. This option needs to be specified during linking. See <a href="https://www.xilinx.com/html_docs/xilinx2021_1/vitis_doc/vitiscommandcompiler.html#lpy1600804966354">this page</a> for detailed profiling options.</td>
</tr>
<tr>
<td>--profile.trace_memory \&lt;FIFO&gt;:\&lt;size&gt;|\&lt;MEMORY&gt;[\&lt;n&gt;]</td>
<td>When building the hardware target (-t=hw), use this option to specify the type and amount of memory to use for capturing trace data. See <a href="https://www.xilinx.com/html_docs/xilinx2021_1/vitis_doc/vitiscommandcompiler.html#lpy1600804966354">this page</a> for detailed profiling options.</td>
</tr>
<tr>
<td>--config <config_file></config_file></td>
<td>Specifies a configuration file containing V++ switches.</td>
</tr>
</tbody>
</table><p>The information to tell the linker how to connect the HLS/DSP and PL kernels together is described in a configuration file, <code class="docutils literal notranslate"><span class="pre">system_configs/x$(FFT_2D_INSTS).cfg</span></code>. The file describes the overall connection scheme of the system.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">connectivity</span><span class="p">]</span>
<span class="n">nk</span><span class="o">=</span><span class="n">fft_2d</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="n">fft_2d_0</span>
<span class="n">nk</span><span class="o">=</span><span class="n">dma_hls</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="n">dma_hls_0</span>

<span class="c1">#Connections For FFT-2D Insts 0...</span>
<span class="n">stream_connect</span><span class="o">=</span><span class="n">dma_hls_0</span><span class="o">.</span><span class="n">strmOut_to_rowiseFFT</span><span class="p">:</span><span class="n">fft_2d_0</span><span class="o">.</span><span class="n">strmFFTrows_inp</span>
<span class="n">stream_connect</span><span class="o">=</span><span class="n">fft_2d_0</span><span class="o">.</span><span class="n">strmFFTrows_out</span><span class="p">:</span><span class="n">dma_hls_0</span><span class="o">.</span><span class="n">strmInp_from_rowiseFFT</span>
<span class="n">stream_connect</span><span class="o">=</span><span class="n">dma_hls_0</span><span class="o">.</span><span class="n">strmOut_to_colwiseFFT</span><span class="p">:</span><span class="n">fft_2d_0</span><span class="o">.</span><span class="n">strmFFTcols_inp</span>
<span class="n">stream_connect</span><span class="o">=</span><span class="n">fft_2d_0</span><span class="o">.</span><span class="n">strmFFTcols_out</span><span class="p">:</span><span class="n">dma_hls_0</span><span class="o">.</span><span class="n">strmInp_from_colwiseFFT</span>

<span class="p">[</span><span class="n">advanced</span><span class="p">]</span>
<span class="c1"># Disable Profiling in hw_emu so that it is faster...</span>
<span class="n">param</span><span class="o">=</span><span class="n">hw_emu</span><span class="o">.</span><span class="n">enableProfiling</span><span class="o">=</span><span class="n">false</span>

<span class="c1"># Export the xsa of the design..</span>
<span class="n">param</span><span class="o">=</span><span class="n">compiler</span><span class="o">.</span><span class="n">addOutputTypes</span><span class="o">=</span><span class="n">hw_export</span>
</pre></div>
</div>
<p>See <a class="reference external" href="https://www.xilinx.com/html_docs/xilinx2021_1/vitis_doc/vitiscommandcompiler.html?hl=--config#pni1524163195211">this page</a> for a detailed description of the Vitis compiler configuration file. A summary of the configuration options used is provided in the following table.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Switch</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>--connectivity.nk</td>
<td>Number of kernels. <code>dma_hls:1:dma_hls_0</code> means that the Vitis compiler should instantiate one dma_hls kernel and name the instance <code>dma_hls_0</code>.</td>
</tr>
<tr>
<td>--connectivity.stream_connect</td>
<td>How the kernels will connect to IPs, platforms, or other kernels. The elaborates the streaming port connections like. <code>dma_hls_0.strmOut_to_rowiseFFT:fft_2d_0.strmFFTrows_inp</code> means that the Vitis compiler should connect the port <code>strmOut_to_rowiseFFT</code> of <code>dma_hls_0</code> HLS kernel to the <code>strmFFTrows_inp</code> of the <code>fft_2d_0</code> HLS kernel.</td>
</tr>
<tr>
<td>param=compiler.addOutputTypes=hw_export</td>
<td>This option tells the Vitis compiler that besides creating an XCLBIN file, it also outputs an XSA file which is needed to create a post-Vivado fixed platform for Vitis software development.</td>
</tr>
</tbody>
</table><p>The Vitis compiler calls the Vivado® IP integrator under the hood to build the design. The platform and kernels are input to the Vivado Design Suite, which produces a simulation XSA or an XSA after running place and route on the design. The point at which the XSA is produced from Vivado depends on the <code class="docutils literal notranslate"><span class="pre">-target</span></code> option set on the Vitis compiler command line.</p>
<p>You can now view the Vivado project, which is located in the <code class="docutils literal notranslate"><span class="pre">$(BUILD_TARGET_DIR)/_x/link/vivado/vpl/prj</span></code> directory. You have now have generated the XCLBIN file, <code class="docutils literal notranslate"><span class="pre">$(BUILD_TARGET_DIR)/vck190_dsp_fft_2d.hw_emu.xclbin</span></code>, that will be used to execute your design on the platform.</p>
<details>
<summary>make application: Compile the Host Application</summary> </details>
<h2>make application: Compile the Host Application</h2>
<p>You can compile the host application by following the typical cross-compilation flow for the Cortex A72 processor. To build the application, run the following command (default <code class="docutils literal notranslate"><span class="pre">FFT_2D_INSTS=1</span></code>, <code class="docutils literal notranslate"><span class="pre">ITER_CNT=8</span></code>, <code class="docutils literal notranslate"><span class="pre">FFT_2D_PT=2048</span></code>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">application</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>cd $(BUILD_TARGET_DIR);	\

aarch64-xilinx-linux-g++ -mcpu=cortex-a72.cortex-a53 -march=armv8-a+crc -fstack-protector-strong \
   -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security -Werror=format-security --sysroot=$(SDKTARGETSYSROOT) -O -c \
   -std=c++14 -D__linux__ -DFFT2D_INSTS=10 -DITER_CNT=8 -DMAT_ROWS=1024 -DMAT_COLS=2048 \
   -I$(SDKTARGETSYSROOT)/usr/include/xrt -I$(SDKTARGETSYSROOT)/usr/include -I$(SDKTARGETSYSROOT)/usr/lib \
   -I$(HOST_APP_SRC) $(HOT_APP_SRC)/fft_2d_dsp_app.cpp -o $(BUILD_TARGET_DIR)/fft_2d_dsp_app.o \
   -L$(SDKTARGETSYSROOT)/lib -lxrt_coreutil

aarch64-xilinx-linux-g++  -mcpu=cortex-a72.cortex-a53 -march=armv8-a+crc -fstack-protector-strong \
   -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security -Werror=format-security --sysroot=$(SDKTARGETSYSROOT) \
   $(BUILD_TARGET_DIR)/fft_2d_dsp_app.o -L$(SDKTARGETSYSROOT)/usr/lib -lxrt_coreutil \
   -o $(BUILD_TARGET_DIR)/fft_2d_dsp_xrt.elf
</pre></div>
</div>
<p>See <a class="reference external" href="https://xilinx.github.io/XRT/2021.1/html/index.html">this page</a> for XRT documentation. See <a class="reference external" href="https://www.xilinx.com/html_docs/xilinx2021_1/vitis_doc/devhostapp.html#vpy1519742402284">this page</a> for details of host application programming.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Switch</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>-O | Optimize.</td>
<td>Optimizing compilation takes somewhat more time, and a lot more memory for a large function. With -O, the compiler tries to reduce code size and execution time, without performing any optimizations that can take a great deal of compilation time.</td>
</tr>
<tr>
<td>-D__linux__</td>
<td></td>
</tr>
<tr>
<td>-DXAIE_DEBUG</td>
<td>Enable debug interface capabilities where certain core status, event status, or stack trace can be dumped out.</td>
</tr>
<tr>
<td>-D\&lt;Pre-processor Macro String&gt;=\&lt;value&gt;</td>
<td>Pass Pre-processor Macro definitions to the cross-compiler.</td>
</tr>
<tr>
<td>-I \&lt;dir&gt;</td>
<td>Add the directory <code>dir</code> to the list of directories to be searched for header files.</td>
</tr>
<tr>
<td>-o \&lt;file&gt;</td>
<td>Place output in file <code>&lt;file&gt;</code>. This applies regardless of the output being produced, whether it be an executable file, an object file, an assembler file or preprocessed C code.</td>
</tr>
<tr>
<td>--sysroot=\&lt;dir&gt;</td>
<td>Use <code>dir</code> as the logical root directory for headers and libraries. For example, if the compiler would normally search for headers in <code>/usr/include</code> and libraries in <code>/usr/lib</code>, it will instead search <code>dir/usr/include</code> and <code>dir/usr/lib</code>. This is automatically set by the <code>env_setup.sh</code> script</td>
</tr>
<tr>
<td>-l\&lt;library&gt;</td>
<td>Search the library named <code>library</code> when linking. The 2D-FFT tutorial requires <code>adf_api_xrt</code> and <code>xrt_coreutil</code> libraries.</td>
</tr>
<tr>
<td>-L \&lt;dir&gt;</td>
<td>Add directory <code>&lt;dir&gt;</code> to the list of directories to be searched for -l.</td>
</tr>
</tbody>
</table><p>The following is a description of the input sources compiled by the cross-compiler compiler command.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Inputs Sources</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>$(HOST_APP_SRC)/fft_2d_dsp_app.cpp</td>
<td>Source application file for the <code>fft_2d_dsp_xrt.elf</code> that will run on an A72 processor.</td>
</tr>
</tbody>
</table><p>The following is a description of the output objects that results from executing the cross-compiler command with the above inputs and options.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Output Objects</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>$(BUILD_TARGET_DIR)/fft_2d_dsp_xrt.elf</td>
<td>The executable that will run on an A72 processor.</td>
</tr>
</tbody>
</table><details>
<summary>make package: Packaging the Design</summary> </details>
<h2>make package: Packaging the Design</h2>
<p>With the HLS/DSP outputs created, as well as the new platform, you can now generate the programmable device image (PDI) and a package to be used on an SD card. The PDI contains all the executables, bitstreams, and configurations of the device. The packaged SD card directory contains everything to boot Linux, the generated applications, and the XCLBIN.</p>
<p>The command to run this step is as follows (default <code class="docutils literal notranslate"><span class="pre">TARGET=hw_emu</span></code>, <code class="docutils literal notranslate"><span class="pre">EN_TRACE=0</span></code>, <code class="docutils literal notranslate"><span class="pre">FFT_2D_INSTS=1</span></code>, <code class="docutils literal notranslate"><span class="pre">FFT_2D_PT=2048</span></code>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">package</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>cp $(PROJECT_REPO)/run_script.sh $(BUILD_TARGET_DIR)/
cd $(BUILD_TARGET_DIR);	\

v++ -p -t hw --save-temps --temp_dir $(BUILD_TARGET_DIR)/_x -f xilinx_vck190_base_202110_1 \
   --package.rootfs $(XLNX_VERSAL)/rootfs.ext4 --package.kernel_image $(XLNX_VERSAL)/Image --package.boot_mode=sd \
   --package.out_dir $(BUILD_TARGET_DIR)/package --package.image_format=ext4 --package.sd_file $(BUILD_TARGET_DIR)/fft_2d_dsp_xrt.elf \
   $(BUILD_TARGET_DIR)/vck190_dsp_fft_2d.hw.xclbin
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">EN_TRACE</span></code> is enabled, the following Vitis compiler flags are also set:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   --package.sd_file $(PROFILING_CONFIGS_REPO)/xrt.ini
</pre></div>
</div>
<p>If the <code class="docutils literal notranslate"><span class="pre">XRT_ROOT</span></code> is set, the following Vitis compiler flags are also set:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   --package.sd_dir $(XRT_ROOT)
</pre></div>
</div>
<p>See <a class="reference external" href="https://www.xilinx.com/html_docs/xilinx2021_1/vitis_doc/packagesystem1.html#cwq1586366344968">this page</a> for more details about packaging the system.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Switch</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>--target | -t [hw|hw_emu]</td>
<td>Specifies the build target.</td>
</tr>
<tr>
<td>--package | -p</td>
<td>Packages the final product at the end of the Vitis compile and link build process.</td>
</tr>
<tr>
<td>--package.rootfs \&lt;arg&gt;</td>
<td>Where \&lt;arg&gt; specifies the absolute or relative path to a processed Linux root file system file. The platform RootFS file is available for download from xilinx.com. Refer to the <a href="https://www.xilinx.com/html_docs/xilinx2021_1/vitis_doc/acceleration_installation.html">Vitis Software Platform Installation</a> for more information.</td>
</tr>
<tr>
<td>--package.kernel_image \&lt;arg&gt;</td>
<td>Where \&lt;arg&gt; specifies the absolute or relative path to a Linux kernel image file. Overrides the existing image available in the platform. The platform image file is available for download from xilinx.com. Refer to the <a href="https://www.xilinx.com/html_docs/xilinx2021_1/vitis_doc/acceleration_installation.html">Vitis Software Platform Installation</a> for more information.</td>
</tr>
<tr>
<td>--package.boot_mode \&lt;arg&gt;</td>
<td>Where \&lt;arg&gt; specifies <ospi\|qspi\|sd> Boot mode used for running the application in emulation or on hardware.</ospi\|qspi\|sd></td>
</tr>
<tr>
<td>--package.image_format</td>
<td>Where \&lt;arg&gt; specifies \&lt;ext4|fat32&gt; output image file format. <code>ext4</code> is the Linux file system and <code>fat32</code> is the Windows file system.</td>
</tr>
<tr>
<td>--package.sd_file</td>
<td>Where \&lt;arg&gt; specifies an ELF or other data file to package into the <code>sd_card</code> directory/image. This option can be used repeatedly to specify multiple files to add to the <code>sd_card</code>.</td>
</tr>
</tbody>
</table><table border="1" class="docutils">
<thead>
<tr>
<th>Inputs Sources</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>$(XRT_ROOT)</td>
<td>The PS host application needs the XRT headers in this folder to execute. Set in the <code>env_setup.sh</code>.</td>
</tr>
<tr>
<td>$(XLNX_VERSAL)/rootfs.ext4</td>
<td>The root filesystem file for PetaLinux.</td>
</tr>
<tr>
<td>$(XLNX_VERSAL)/Image</td>
<td>The pre-built PetaLinux image the processor boots from.</td>
</tr>
<tr>
<td>$(BUILD_TARGET_DIR)/fft_2d_dsp_xrt.elf</td>
<td>The PS host application executable created in the <code>make application</code> step.</td>
</tr>
<tr>
<td>$(BUILD_TARGET_DIR)/vck190_dsp_fft_2d.hw_emu.xclbin</td>
<td>The XCLBIN file created in the <code>make xclbin</code> step.</td>
</tr>
</tbody>
</table><p>The output of the V++ Package step is the package directory that contains the contents to run hardware emulation.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Output Objects</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>$(BUILD_TARGET_DIR)/package</td>
<td>The hardware emulation package that contains the boot file, hardware emulation launch script, the PLM and PMC boot files, the PMC and QEMU command argument specification files, and the Vivado simulation folder.</td>
</tr>
</tbody>
</table><details>
<summary>make run_emu: Running Hardware Emulation</summary></details>
<h2>make run_emu: Running Hardware Emulation</h2>
<p>After packaging, everything is set to run hardware emulation. To run emulation, use the following command (default <code class="docutils literal notranslate"><span class="pre">TARGET=hw_emu</span></code>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">run_emu</span> 
</pre></div>
</div>
<p>or</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>###########################################################################
Hardware Emulation Goto:
$(BUILD_TARGET_DIR)/package

and do:
./launch_hw_emu.sh or ./launch_hw_emu.sh -g (for waveform viewer)...
</pre></div>
</div>
<p>When hardware emulation is launched, you will see the QEMU simulator load. Wait for the autoboot countdown to go to zero. After a few minutes, the root Linux prompt comes up:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>root@versal-rootfs-common-2021.1:~#
</pre></div>
</div>
<p>After the root prompt comes up, run the following commands to run the design:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mount</span> <span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">mmcblk0p1</span> <span class="o">/</span><span class="n">mnt</span>
<span class="n">cd</span> <span class="o">/</span><span class="n">mnt</span>
<span class="n">export</span> <span class="n">XILINX_XRT</span><span class="o">=/</span><span class="n">usr</span>
<span class="o">./</span><span class="n">fft_2d_dsp_xrt</span><span class="o">.</span><span class="n">elf</span> <span class="n">a</span><span class="o">.</span><span class="n">xclbin</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">fft_2d_aie_xrt.elf</span></code> executes. After a few minutes, you should see the output with <code class="docutils literal notranslate"><span class="pre">TEST</span> <span class="pre">PASSED</span></code> on the console. When this is shown, run the following keyboard command to exit the QEMU instance:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#To exit QEMU Simulation</span>
<span class="n">Press</span> <span class="n">CtrlA</span><span class="p">,</span> <span class="n">let</span> <span class="n">go</span> <span class="n">of</span> <span class="n">the</span> <span class="n">keyboard</span><span class="p">,</span> <span class="ow">and</span> <span class="n">then</span> <span class="n">press</span> <span class="n">x</span> 
</pre></div>
</div>
<p>To run with waveform, do the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>cd $(BUILD_TARGET_DIR)/package
./launch_hw_emu.sh -g
</pre></div>
</div>
<p>The XSIM Waveform Viewer is launched. Drag and drop the signals into the viewer and click <strong>Play</strong> to start the emulation. Go back to the terminal and wait for the Linux prompt to show up. In the XSIM Waveform Viewer, you will see the signals you added to the waveform adjusting over the execution of the design. When this is done, hit the pause button and close the window to end the emulation.</p>
<p>The following figure shows a waveform view of the 32x64 - 1x design.</p>
<p><img alt="Image of 2D-FFT DSP HW_EMU run Waveform View For 32x64-1x Design" src="../../../../../_images/fft_2d_dsp_hw_emu_waveform_view_32x64_x1.PNG"/></p>
<details>
<summary>TARGET=hw: Running on Hardware</summary></details>
<h2>Running on Hardware</h2>
<p>To run the design in hardware, rerun the following <code class="docutils literal notranslate"><span class="pre">make</span></code> steps with <code class="docutils literal notranslate"><span class="pre">TARGET=hw</span></code> and other applicable options (see the preceding <code class="docutils literal notranslate"><span class="pre">make</span></code> steps specified above).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">kernels</span> <span class="n">TARGET</span><span class="o">=</span><span class="n">hw</span>
<span class="n">make</span> <span class="n">xclbin</span> <span class="n">TARGET</span><span class="o">=</span><span class="n">hw</span> 
<span class="n">make</span> <span class="n">package</span> <span class="n">TARGET</span><span class="o">=</span><span class="n">hw</span> 
</pre></div>
</div>
<p>These commands create a <code class="docutils literal notranslate"><span class="pre">$(BUILD_TARGET_DIR)</span></code> folder with the kernels, XCLBIN, and <code class="docutils literal notranslate"><span class="pre">package</span></code> for a hardware run.</p>
<p>Run the following step to set up the execution file, generated images, and base images (<code class="docutils literal notranslate"><span class="pre">$(BUILD_TARGET_DIR)/package/sd_card</span></code> and <code class="docutils literal notranslate"><span class="pre">$(BUILD_TARGET_DIR)/package/sd_card.img</span></code>).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">run_emu</span> <span class="n">TARGET</span><span class="o">=</span><span class="n">hw</span> 
</pre></div>
</div>
<p>These commands create a <code class="docutils literal notranslate"><span class="pre">build/hw</span></code> folder with the kernels, XCLBIN, and <code class="docutils literal notranslate"><span class="pre">package</span></code> for a hardware run. Follow steps 1-9 to run the <code class="docutils literal notranslate"><span class="pre">fft_2d_dsp_xrt.elf</span></code> executable on your VCK190 board.</p>
<p><strong>Step 1.</strong> Ensure your board is powered off.</p>
<p><strong>Step 2.</strong> Use an SD card writer (such as balenaEtcher) to flash the <code class="docutils literal notranslate"><span class="pre">sd_card.img</span></code> file to an SD card.</p>
<p><strong>Step 3.</strong> Plug the flashed SD card into the top slot of the VCK190 board.</p>
<p><strong>Step 4.</strong> Set the switch (<code class="docutils literal notranslate"><span class="pre">SW1</span> <span class="pre">Mode\[3:0\]=1110</span> <span class="pre">=</span> <span class="pre">OFF</span> <span class="pre">OFF</span> <span class="pre">OFF</span> <span class="pre">ON</span></code>).</p>
<p><strong>Step 5.</strong> Connect your computer to the VCK190 board using the USB cable included with the board.</p>
<p><strong>Step 6.</strong> Open a TeraTerm terminal and select the correct COM port. Set the port settings to the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Port</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">COMMXX</span><span class="o">&gt;</span>
<span class="n">Speed</span><span class="p">:</span> <span class="mi">115200</span>
<span class="n">Data</span><span class="p">:</span> <span class="mi">8</span> <span class="n">bit</span>
<span class="n">Parity</span><span class="p">:</span> <span class="n">none</span>
<span class="n">Stop</span> <span class="n">Bits</span><span class="p">:</span> <span class="mi">1</span> <span class="n">bit</span>
<span class="n">Flow</span> <span class="n">control</span><span class="p">:</span> <span class="n">none</span>
<span class="n">Transmit</span> <span class="n">delay</span><span class="p">:</span> <span class="mi">0</span> <span class="n">msec</span><span class="o">/</span><span class="n">char</span> <span class="mi">0</span> <span class="n">msec</span><span class="o">/</span><span class="n">line</span>
</pre></div>
</div>
<p><strong>Step 7.</strong> Power on the board.</p>
<p><strong>Step 8.</strong> Wait until you see the <code class="docutils literal notranslate"><span class="pre">root@versal-rootfs-common-2021_1</span></code> Linux command prompt. Press enter a few times to get past any <code class="docutils literal notranslate"><span class="pre">xinit</span></code> errors.</p>
<p><strong>Step 9.</strong> Run the following commands in the TeraTerm terminal:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="o">/</span><span class="n">mnt</span><span class="o">/</span><span class="n">sd</span><span class="o">-</span><span class="n">mmcblk0p1</span>
<span class="n">export</span> <span class="n">XILINX_XRT</span><span class="o">=/</span><span class="n">usr</span>
<span class="o">./</span><span class="n">init</span><span class="o">.</span><span class="n">sh</span>

<span class="o">./</span><span class="n">fft_2d_dsp_xrt</span><span class="o">.</span><span class="n">elf</span> <span class="n">a</span><span class="o">.</span><span class="n">xclbin</span>
</pre></div>
</div>
<details>
<summary>2D-FFT HLS Implementation Architecture and DSP/PL Function Partitioning</summary>
<h2>2D-FFT HLS Implementation Architecture and DSP/PL Function Partitioning</h2>
<p>The following figure shows a high-level block diagram of the design. The test harness consists of the HLS FFT kernels using DSP Engines and the data mover HLS kernels (<code class="docutils literal notranslate"><span class="pre">dma_hls</span></code>). In this setup, there is an AXI4-Stream interface between the data mover kernels and DSP Engines, with a data width of 128 bits. The data mover kernel is running at 250 MHz and the HLS/DSP kernel is running at 500 MHz.</p>
<p>The data mover is a PL-based data generator and checker. It generates impulse input and checks the output of the row-wise FFT core for its response. It then generates the transposed pattern of the row-wise FFT output and feeds that to the col-wise FFT core and checks its output.</p>
<p><img alt="Image of 2D-FFT DSP Implementation Architecture" src="../../../../../_images/fft_2d_dsp_block_diagram.PNG"/></p>
</details><details>
<summary>Design Details</summary></details>
<h2>Design Details</h2>
<p>The design in this tutorial starts with a base platform containing the control interface and processing system (CIPS), NoC, DSP, and the interfaces among them. The Vitis compiler linker step builds on top of the base platform by adding the PL/HLS kernels. To add the various functions in a system-level design, PL kernels are added to the base platform depending on the application (that is, the PL kernels present in each design might vary). In the design, the components are added by the Vitis compiler <code class="docutils literal notranslate"><span class="pre">-l</span></code> step (see <a class="reference external" href="#make-xclbin-using-the-vitis-tools-to-link-hls-kernels-with-the-platform">make XCLBIN</a>) and include the following:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fft_2d</span></code> HLS/DSP kernel (<code class="docutils literal notranslate"><span class="pre">fft_2d.[hw|hw_emu].xo</span></code>)</p></li>
<li><p>Data mover kernel (<code class="docutils literal notranslate"><span class="pre">dma_hls.[hw|hw_emu].xo</span></code>)</p></li>
<li><p>Connections interfaces defined in the system configuration file</p></li>
</ul>
<p>To see a schematic view of the design with the extended platform as shown in the following figure, open the following in Vivado:</p>
<p><code class="docutils literal notranslate"><span class="pre">build/fft2d_$(MAT_ROWS)x$(MAT_COLS)/x$(FFT_2D_INSTS)/[hw|hw_emu]/_x/link/vivado/vpl/prj/prj.xpr</span></code></p>
<p><img alt="Image of 2D-FFT DSP 1x Vivado BD" src="../../../../../_images/fft_2d_dsp_1x_vivado_bd.PNG"/></p>
<p>In this design, the 2D FFT computation happens in two stages: the first compute is across the row vectors (the <code class="docutils literal notranslate"><span class="pre">fft_rows</span></code> function in the <code class="docutils literal notranslate"><span class="pre">fft_2d</span></code> kernel) and the second stage is performed across the column vectors(<code class="docutils literal notranslate"><span class="pre">fft_cols</span></code> function in the <code class="docutils literal notranslate"><span class="pre">fft_2d</span></code> kernel). The input data is accessed linearly and streamed to the HLS/DSP kernels which perform <code class="docutils literal notranslate"><span class="pre">MAT_COLS(</span> <span class="pre">default</span> <span class="pre">2048</span> <span class="pre">)</span></code> point FFT. The data coming out of the HLS/DSP kernels is streamed to a PL kernel where it is checked against the expected pattern (the first row should be 1 and the remaining should be 0). If there is a mismatch, it is recorded in the variable <code class="docutils literal notranslate"><span class="pre">stage0_errCnt</span></code>. The transposed pattern of the output of the row vectors is then linearly streamed into another HLS/DSP kernel which performs <code class="docutils literal notranslate"><span class="pre">MAT_ROWS(</span> <span class="pre">default</span> <span class="pre">1024</span> <span class="pre">)</span></code> point FFT. The output is streamed into the data mover kernel again and is checked against the expected pattern (all values should be 1). If there is a mismatch, it is stored in the variable <code class="docutils literal notranslate"><span class="pre">stage1_errCnt</span></code>. Finally, the sum of <code class="docutils literal notranslate"><span class="pre">stage0_errCnt</span></code> and <code class="docutils literal notranslate"><span class="pre">stage1_errCnt</span></code> is returned from the kernel, which is read in the host app to determine whether the test has passed or failed.</p>
<p>The system debugging and profiling IP (DPA) is added to the PL region of the device to capture HLS/DSP kernel’s runtime trace data if the <code class="docutils literal notranslate"><span class="pre">EN_TRACE</span></code> option is enabled in the design. The <code class="docutils literal notranslate"><span class="pre">dma_hls</span></code> kernel operates at 250 MHz and the HLS/DSP kernel operates at 500 MHz: unlike the AI Engine implementation, there is a clock domain crossing in the PL region in this design.</p>
<details>
<summary>HLS/PL Kernels</summary></details>
<h2>HLS/PL Kernels</h2>
<p>The top-level HLS/DSP kernel, <code class="docutils literal notranslate"><span class="pre">fft_2d</span></code>, contains two sub-functions: <code class="docutils literal notranslate"><span class="pre">fft_rows</span></code> and <code class="docutils literal notranslate"><span class="pre">fft_cols</span></code>. Each sub-function contains the individual HLS/DSP kernels which perform <code class="docutils literal notranslate"><span class="pre">MAT_COLS</span></code> and <code class="docutils literal notranslate"><span class="pre">MAT_ROWS</span></code> point FFT respectively.</p>
<p>The PL-based data movers consist of the <code class="docutils literal notranslate"><span class="pre">dma_hls</span></code> kernel, which generates impulse input and checks the output of each FFT stage for the expected pattern.</p>
<h3>FFT_2D</h3>
<ul class="simple">
<li><p>Internally comprises two functions: <code class="docutils literal notranslate"><span class="pre">fft_rows</span></code> and <code class="docutils literal notranslate"><span class="pre">fft_cols</span></code>. Both functions are concurrently scheduled.</p></li>
<li><p>The data width is 128 bits at both input and output (I/O) AXI4-Stream interfaces.</p></li>
<li><p>Working at 500 MHz.</p></li>
</ul>
<h3>DMA_HLS</h3>
<ul class="simple">
<li><p>Internally comprises four loops (<code class="docutils literal notranslate"><span class="pre">mm2s0</span></code>, <code class="docutils literal notranslate"><span class="pre">s2mm0</span></code> , <code class="docutils literal notranslate"><span class="pre">mm2s1</span></code>, and <code class="docutils literal notranslate"><span class="pre">s2mm1</span></code>). <code class="docutils literal notranslate"><span class="pre">s2mm0</span></code> and <code class="docutils literal notranslate"><span class="pre">mm2s1</span></code> are sequenced one after the other and wrapped into the <code class="docutils literal notranslate"><span class="pre">dmaHls_rowsToCols</span></code>. <code class="docutils literal notranslate"><span class="pre">dmaHls_rowsToCols</span></code> and <code class="docutils literal notranslate"><span class="pre">s2mm1</span></code> are concurrently scheduled.</p></li>
<li><p>The data width is 128 bits at both the AXI4-Stream I/O side.</p></li>
<li><p>Working at 250 MHz.</p></li>
</ul>
<p>The software design in the HLS/DSP 2D-FFT tutorial consists of the following sections:</p>
<details>
<summary>Methodology</summary>
<h2>Methodology</h2>
<p>The following figure elaborates on the HLS implementation using DSP Engines methodology.</p>
<p><img alt="Image of 2D-FFT DSP Implementation Methodology" src="../../../../../_images/fft_2d_dsp_block_diagram_methodology.PNG"/></p>
<h3>DSP</h3>
<h4>Concurrent Scheduling</h4>
<p>Concurrent scheduling is required so that each function runs independently and the execution of one function does not block the other. Both DSP HLS sub-functions, <code class="docutils literal notranslate"><span class="pre">fft_rows</span></code> and <code class="docutils literal notranslate"><span class="pre">fft_cols</span></code>, are configured independently of one other, with concurrent scheduling achieved using <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">HLS</span> <span class="pre">DATAFLOW</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="c1">#pragma HLS DATAFLOW</span>

<span class="n">ITER_LOOP_FFT_ROWS</span><span class="p">:</span><span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iterCnt</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">fft_rows</span><span class="p">(</span><span class="n">strmFFTrows_inp</span><span class="p">,</span> <span class="n">strmFFTrows_out</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">ITER_LOOP_FFT_COLS</span><span class="p">:</span><span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iterCnt</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">fft_cols</span><span class="p">(</span><span class="n">strmFFTcols_inp</span><span class="p">,</span> <span class="n">strmFFTcols_out</span><span class="p">);</span>
<span class="p">}</span>
<span class="o">...</span>
</pre></div>
</div>
<h4>Sub-Functions are Pipelined and Set Up in DATAFLOW</h4>
<p>Pipelining reduces the initiation interval (II) for a function or loop by allowing the concurrent execution of operations. The default type of pipeline is defined by the <code class="docutils literal notranslate"><span class="pre">config_compile</span> <span class="pre">-pipeline_style</span></code> command, but can be overridden in the <a class="reference external" href="https://www.xilinx.com/html_docs/xilinx2021_1/vitis_doc/hls_pragmas.html#fde1504034360078">PIPELINE pragma</a> or directive.</p>
<p>The <a class="reference external" href="https://www.xilinx.com/html_docs/xilinx2021_1/vitis_doc/hls_pragmas.html#sxx1504034358866">DATAFLOW pragma</a> enables task-level pipelining as described in <a class="reference external" href="https://www.xilinx.com/html_docs/xilinx2021_1/vitis_doc/vitis_hls_optimization_techniques.html#bmx1539734225930">Exploiting Task Level Parallelism: Dataflow Optimization</a>, allowing functions and loops to overlap in their operation, increasing the concurrency of the RTL implementation and increasing the overall throughput of the design.</p>
<p>All operations are performed sequentially in a C description. In the absence of any directives that limit resources (such as pragma HLS allocation), the Vitis HLS tool seeks to minimize latency and improve concurrency. However, data dependencies can limit this. For example, functions or loops that access arrays must finish all read/write accesses to the arrays before they complete. This prevents the next function or loop that consumes the data from starting operation. The DATAFLOW optimization enables the operations in a function or loop to start operation before the previous function or loop completes all its operations.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">fft_rows</span></code> function performs <code class="docutils literal notranslate"><span class="pre">MAT_COLS</span></code> point FFT and runs for <code class="docutils literal notranslate"><span class="pre">MAT_ROWS</span></code> number of iterations (and vice versa for the <code class="docutils literal notranslate"><span class="pre">fft_cols</span></code> function). Each loop within these functions is pipelined with <code class="docutils literal notranslate"><span class="pre">II=1</span></code> and are called under <code class="docutils literal notranslate"><span class="pre">DATAFLOW</span></code>. The following code snippet shows the <code class="docutils literal notranslate"><span class="pre">fft_rows</span></code> functions as an example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="n">LOOP_FFT_ROWS</span><span class="p">:</span><span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAT_ROWS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>

   <span class="c1">#pragma HLS DATAFLOW</span>

   <span class="n">readIn_row</span><span class="p">(</span><span class="n">strm_inp</span><span class="p">,</span> <span class="ow">in</span><span class="p">);</span>  <span class="o">//</span> <span class="n">Pipelined</span> <span class="k">with</span> <span class="n">II</span><span class="o">=</span><span class="mi">1</span> <span class="n">inside</span><span class="o">...</span>
   
   <span class="n">fftRow</span><span class="p">(</span><span class="n">directionStub</span><span class="p">,</span> <span class="ow">in</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ovfloStub</span><span class="p">);</span>

   <span class="n">writeOut_row</span><span class="p">(</span><span class="n">strm_out</span><span class="p">,</span> <span class="n">out</span><span class="p">);</span>  <span class="o">//</span> <span class="n">Pipelined</span> <span class="k">with</span> <span class="n">II</span><span class="o">=</span><span class="mi">1</span> <span class="n">inside</span><span class="o">...</span>
<span class="p">}</span>
<span class="o">...</span>
</pre></div>
</div>
<p>Pipelining reduces the execution latency. Moreover, establishing dataflow within the sub-functions reduces all overhead latency in terms of reading/writing input and output respectively; see the following figure.</p>
<p><img alt="Image of FFT_2D Synthesis Report" src="../../../../../_images/fft_2d_dsp_synth_rpt_view.PNG"/></p>
<h4>Vitis HLS Scheduling and Dataflow View For FFT_2D</h4>
<p>The following figure shows the scheduler view.</p>
<p><img alt="Image of FFT_2D Scheduler View" src="../../../../../_images/fft_2d_dsp_scheduler_view.PNG"/></p>
<p>The following figure shows the dataflow view.</p>
<p><img alt="Image of FFT_2D Dataflow View" src="../../../../../_images/fft_2d_dsp_dataflow_view.PNG"/></p>
<h3>Data Mover</h3>
<h4>Data Generation/Checking and Sequencing</h4>
<p>The data mover comprises four loops: <code class="docutils literal notranslate"><span class="pre">mm2s0</span></code>, <code class="docutils literal notranslate"><span class="pre">s2mm0</span></code>, <code class="docutils literal notranslate"><span class="pre">mm2s1</span></code>, and <code class="docutils literal notranslate"><span class="pre">s2mm1</span></code>. The <code class="docutils literal notranslate"><span class="pre">s2mm0</span></code> and <code class="docutils literal notranslate"><span class="pre">mm2s1</span></code> functions are wrapped into a single function, <code class="docutils literal notranslate"><span class="pre">dmaHls_rowsToCols</span></code>. Within that the execution sequence, <code class="docutils literal notranslate"><span class="pre">s2mm0</span></code> is followed by <code class="docutils literal notranslate"><span class="pre">mm2s1</span></code>. The <code class="docutils literal notranslate"><span class="pre">s2mm0</span></code> and <code class="docutils literal notranslate"><span class="pre">s2mm1</span></code> functions check the output of the row-wise and col-wise FFT respectively against the expected golden output.</p>
<h4>Concurrent Scheduling</h4>
<p>Concurrent scheduling is required so that each function runs independently and the execution of one function is not blocking the other. The concurrent scheduling of the three functions <code class="docutils literal notranslate"><span class="pre">mm2s0</span></code>, <code class="docutils literal notranslate"><span class="pre">dmaHls_rowsToCols</span></code>, and <code class="docutils literal notranslate"><span class="pre">s2mm1</span></code> is achieved using <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">HLS</span> <span class="pre">DATAFLOW</span></code> as shown in the following example.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#pragma HLS DATAFLOW</span>
<span class="o">...</span>
<span class="n">LOOP_ITER_MM2S0</span><span class="p">:</span><span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iterCnt</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
   <span class="c1">#pragma HLS loop_tripcount min=1 max=8</span>
   
   <span class="n">mm2s0</span><span class="p">(</span><span class="n">strmOut_to_rowiseFFT</span><span class="p">,</span> <span class="n">matSz</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">LOOP_ITER_S2MM0_TO_MM2S1</span><span class="p">:</span><span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iterCnt</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
   <span class="c1">#pragma HLS loop_tripcount min=1 max=8</span>
   
   <span class="n">dmaHls_rowsToCols</span><span class="p">(</span><span class="n">strmInp_from_rowiseFFT</span><span class="p">,</span> <span class="n">strmOut_to_colwiseFFT</span><span class="p">,</span> \
                     <span class="n">matSz</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">stg0_errCnt</span><span class="p">,</span> <span class="n">goldenVal</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">LOOP_ITER_S2MM1</span><span class="p">:</span><span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iterCnt</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
   <span class="c1">#pragma HLS loop_tripcount min=1 max=8</span>
   
   <span class="n">s2mm1</span><span class="p">(</span><span class="n">strmInp_from_colwiseFFT</span><span class="p">,</span> <span class="n">matSz</span><span class="p">,</span> <span class="n">stg1_errCnt</span><span class="p">,</span> <span class="n">goldenVal</span><span class="p">);</span>
<span class="p">}</span>
<span class="o">...</span>
</pre></div>
</div>
<h4>Vitis HLS Scheduling and Dataflow View for DMA_HLS</h4>
<p>The following figure shows the scheduler view.</p>
<p><img alt="Image of Datamover Scheduler View" src="../../../../../_images/dma_hls_scheduler_view1.PNG"/></p>
<p>The following figure shows the dataflow view.</p>
<p><img alt="Image of Datamover Dataflow View" src="../../../../../_images/dma_hls_dataflow_view1.PNG"/></p>
<h3>Streaming Interface Data Width</h3>
<p>The streaming interface data width is kept as 128 bits to reduce read/write overhead while processing data.</p>
<h3>Frequency Selection</h3>
<p>In the HLS implementation, due to timing closure limitations, the <code class="docutils literal notranslate"><span class="pre">fft_2d</span></code> kernel is kept at 500 MHz and the data mover is kept at 250 MHz.</p>
<h3>Timing Closure</h3>
<p>For timing closure of the whole design, different implementation properties are used, as mentioned in the <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">xclbin</span></code> step above. These strategies are required because timing closure does not happen for the design if the default implementation settings are used.</p>
<p>For the purposes of achieving timing closure for the 256 x 512 point x10 and 1024 x 2048 point x10 designs, over 200 implementation strategies were used, out of which three met timing. Out of that, those with the least power were chosen as the implementation strategy in the <code class="docutils literal notranslate"><span class="pre">v++</span> <span class="pre">-l</span> <span class="pre">/</span> <span class="pre">make</span> <span class="pre">xclbin</span></code> step.</p>
<p>For more information about implementation strategies, see the <em>Vivado Implementation User Guide</em> <a class="reference external" href="https://www.xilinx.com/support/documentation/sw_manuals/xilinx2021_1/ug904-vivado-implementation.pdf">UG904</a></p>
</details><details>
<summary>HLS/DSP Kernel Representation</summary></details>
