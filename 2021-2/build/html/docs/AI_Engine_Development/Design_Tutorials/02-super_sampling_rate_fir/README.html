<div class="rst-content">

<table class="sphinxhide" width="100%">
<tr width="100%">
<td align="center"><img src="https://raw.githubusercontent.com/Xilinx/Image-Collateral/main/xilinx-logo.png" width="30%"/>
<a href="https://www.xilinx.com/products/design-tools/vitis.html">See Vitis™ Development Environment on xilinx.com</a>
<a href="https://www.xilinx.com/products/design-tools/vitis/vitis-ai.html">See Vitis-AI™ Development Environment on xilinx.com</a>
</td>
</tr>
</table>
<p><em><strong>Version: Vitis 2021.2</strong></em></p>
<h2>Introduction</h2>
<p>Versal™ ACAP AI Core Series are heterogeneous devices containing many domains with compute capabilities. With respect to Digital Signal Processing (DSP), and particularly Finite Impulse Response (FIR) filters, the two domains of interest are:</p>
<ul class="simple">
<li><p>The Programmable Logic (PL) which is the “classical” domain of Xilinx devices</p></li>
<li><p>The AI Engine Processor Array which is a new domain within Versal ACAP Xilinx devices</p></li>
</ul>
<p>FIR filter architecture is a rich and fruitful electrical engineering domain, especially when the input sampling rate becomes higher than the clock rate of the device (Super Sampling Rate aka. SSR). For the PL there exists a number of solutions that are already available using turnkey IP solution (FIR Compiler). The AI Engine array is a completely new processor and processor array architecture with enormous compute capabilities, so an efficient filtering architecture has to be found using all the capabilities of the AI Engine array, but also all the communications that are possible with the PL.</p>
<p>The purpose of this tutorial is to provide a methodology to enable you to make appropriate choices depending on the filter characteristics, and to provide examples on how to implement Super Sampling Rate (SSR) FIR Filters on a Versal ACAP AI Engine processor array.</p>
<h2>Before You Begin</h2>
<p>Before beginning this tutorial you should be familiar with Versal ACAP architecture and more specifically on the AI Engine array processor and interconnect architecture.</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.xilinx.com/products/silicon-devices/acap/versal-ai-core.html">Xilinx Website for Versal ACAP AI Core Series</a></p></li>
<li><p><a class="reference external" href="https://forums.xilinx.com/t5/Design-and-Debug-Techniques-Blog/Versal-ACAP-AI-Engines-for-Dummies/ba-p/1132493">Introduction to the AI Engine</a></p></li>
<li><p><a class="reference external" href="https://www.xilinx.com/support/documentation/architecture-manuals/am009-versal-ai-engine.pdf">AI Engine Detailed Architecture</a></p></li>
</ul>
<p>Software requirements include:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.xilinx.com/support/download/index.html/content/xilinx/en/downloadNav/vitis.html">Vitis</a></p></li>
<li><p><a class="reference external" href="https://www.python.org/downloads/">Python 3</a></p></li>
<li><p>You also have the possibility to test these architectures on the AI Engine using MATLAB Simulink toolset.</p>
<ul>
<li><p><a class="reference external" href="https://www.mathworks.com/">Mathworks</a> to install <strong>MATLAB</strong> version R2020a, R2020b or R2021a.</p></li>
<li><p><strong>Vitis Model Composer</strong> that is available with the usual install of <strong>Vitis</strong>.</p></li>
</ul>
</li>
</ul>
<ul class="simple">
<li><p><a class="reference external" href="https://www.xilinx.com/support/download/index.html/content/xilinx/en/downloadNav/vitis.html">Vitis</a></p></li>
<li><p><a class="reference external" href="https://www.python.org/downloads/">Python 3</a></p></li>
</ul>
<h3>Accessing the Tutorial Reference Files</h3>
<ol class="simple">
<li><p>To access the reference files, type the following into a terminal: <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">clone</span> <span class="pre">https://github.com/Xilinx/Vitis-Tutorials.git</span></code>.</p></li>
<li><p>Navigate to the <code class="docutils literal notranslate"><span class="pre">Vitis-Tutorials/AI_Engine_Development/Design_Tutorials/02-super_sampling_rate_fir/Utils/</span></code> directory, and type <code class="docutils literal notranslate"><span class="pre">source</span> <span class="pre">InitPythonPath</span></code> to have this directory in your path for Python libraries and executable search path.</p></li>
</ol>
<p>You can now start the tutorial.</p>
<h2>SSR FIR Tutorial</h2>
<p>This tutorial is decomposed into multiple steps:</p>
<ol class="simple">
<li><p><a class="reference external" href="#AIE_Architecture">Summary of AI Engine Architecture</a></p></li>
<li><p><a class="reference external" href="#FIR_Filter">What is a FIR Filter?</a></p></li>
<li><p><a class="reference external" href="#UtilsDirectory">“Utils” directory</a></p></li>
<li><p><a class="reference internal" href="SingleKernel/README.html"><span class="doc">Single Kernel FIR</span></a></p></li>
<li><p><a class="reference internal" href="MultiKernel/README.html"><span class="doc">Multi-Kernel FIR</span></a></p></li>
<li><p>Polyphase FIR (SSR)</p>
<ol class="simple">
<li><p><a class="reference internal" href="SingleStreamSSR/README.html"><span class="doc">Single Stream</span></a></p></li>
<li><p><a class="reference internal" href="DualStreamSSR/README.html"><span class="doc">Double Stream</span></a></p></li>
</ol>
</li>
</ol>
<p><a name="AIE_Architecture"></a></p>
<h2>Summary of AI Engine Architecture</h2>
<p>You should have already read the <a class="reference external" href="https://www.xilinx.com/support/documentation/architecture-manuals/am009-versal-ai-engine.pdf">AI Engine Detailed Architecture</a>, so the purpose of this chapter is simply to highlight the features of the AI Engine that will be useful for this tutorial.</p>
<p>Versal™ Adaptive Compute Acceleration Platforms (ACAPs) combine Scalar Engines, Adaptable Engines, and Intelligent Engines with leading-edge memory and interfacing technologies to deliver powerful heterogeneous acceleration for any application.</p>
<p><img alt="missing image" src="../../../../_images/Versal.jpg"/></p>
<p>Intelligent Engines are SIMD VLIW AI Engines for adaptive inference and advanced signal processing compute.</p>
<p>DSP Engines are for fixed point, floating point, and complex MAC operations.</p>
<p>The SIMD VLIW AI Engines come as an array of interconnected processors using AXI-Stream interconnect blocks as shown in the following figure:</p>
<p><img alt="missing image" src="../../../../_images/AIEngineArray.jpg"/></p>
<p>All arrays (processors, memory modules, AXI interconnects) are driven by a single clock. The slowest speed grade device can run @1 GHz. The highest speedgrade will allow 1.3 GHz clock rates. The AI Engine allows for numerous connection possibilities with the surrounding environment as shown in the following figure.</p>
<p><img alt="missing image" src="../../../../_images/AIEngine.jpg"/></p>
<h3>Memory interface</h3>
<p><img alt="missing image" src="../../../../_images/AIE_MemIF.jpg"/></p>
<p>Each AI Engine is surrounded by 4x 32 kB memories, each one being divided in four pairs of banks. The bandwidth is very high:</p>
<ul class="simple">
<li><p>2 reads / cycle on 32 bytes (256 bits) each</p>
<ul>
<li><p>Each bank having a single port, the accesses must be done on different banks to achieve 2x 256 bits/cycle.</p></li>
</ul>
</li>
<li><p>1 write / cycle on 32 bytes (256 bits)</p>
<ul>
<li><p>On another bank to achieve the highest bandwidth</p></li>
</ul>
</li>
<li><p>Be aware that you need also to feed the memories using DMAs or other AI Engines</p></li>
</ul>
<h3>Streaming interface</h3>
<p><img alt="missing image" src="../../../../_images/AIE_Streams.jpg"/></p>
<p>The streaming interface is based on two incoming streams and two outgoing streams, each one on 32 bits per clock cycle. These four streams are handled by a stream FIFO that allows the processor to use different bitwidths to access these streams:</p>
<ul class="simple">
<li><p>2 streams in, 2 streams out</p>
<ul>
<li><p>Each one 4 bytes/cycle or 16 bytes/ 4 cycles</p></li>
</ul>
</li>
<li><p>Parallel access to streams per VLIW:</p>
<ul>
<li><p>2 reads (4/16 bytes), 1 write (4/16 bytes)</p></li>
<li><p>OR 1 read (4/16 bytes), 2 writes (4/16 bytes)</p></li>
</ul>
</li>
<li><p>Using 1 stream:</p>
<ul>
<li><p>4 bytes/cycle read and 4 bytes/cycle write</p></li>
</ul>
</li>
<li><p>Using the 2 streams and the 16-byte access option</p>
<ul>
<li><p>Reads and/or writes can be dispatched over time</p></li>
<li><p>On average 8 bytes/cycle read and 8 bytes/cycle write</p></li>
</ul>
</li>
</ul>
<p>Accessing the data to/from the streams using the 128 bit interface does not increase the bandwidth, but limits the number of accesses that must be scheduled within the microcode of the VLIW processor.</p>
<h3>Cascade Streams</h3>
<p><img alt="missing image" src="../../../../_images/AIE_Cascade.jpg"/></p>
<p>The cascade stream allows an AI Engine processor to transfer the value of some of its accumulator register (384 bits) to its neighbor (on the left or on the right depending on the row):</p>
<ul class="simple">
<li><p>It is capable of 8x 48-bit word transfer v8acc48 or v4cacc48 in a single cycle</p></li>
<li><p>48 bits is the number of bits of the result of a 16-bits x 16-bits multiplication</p></li>
<li><p>If the transfer concerns a 768 bit register, it will take 2 clock cycles.</p></li>
</ul>
<p><a name="FIR_Filter"></a></p>
<h2>What is a FIR Filter?</h2>
<p>The purpose of this tutorial is not to train you to be an expert in Digital Signal Processing, however to grasp the basics of FIR filtering it is necessary to understand the computations that are required, and the data that are consumed and produced by the compute block.</p>
<p>A digital signal is an analog signal (audio, radio frequencies, …) that has been received by a converter (Analog to Digital Converter: ADC) which performs two operations:</p>
<ul class="simple">
<li><p><strong>Slicing</strong>: The impinging signal is sliced into very small time slots on which its amplitude is approximated by a constant value.</p></li>
<li><p><strong>Quantizing</strong>: Digital systems understand only bits. The constant value at the output of the slicer is transformed into an integer value whose maximum represents the maximum amplitude that the system can receive.</p></li>
</ul>
<p>As a result the digital signal at the output of the ADC is simply a series of <em>N</em>-bits values (called samples) that can be processed to extract some useful information. The most basic operation is to multiply some samples by some specific coefficients and accumulate these values to create a “summary” of this part of the signal.</p>
<p>A filtering operation performs this using a sliding window on the signal as shown in the following figure:</p>
<p><img alt="missing image" src="../../../../_images/FIR_Filter.jpg"/></p>
<p>Input data samples are in general called <strong>x</strong> (blue squares), the coefficients <strong>c</strong> (green squares) and the output samples <strong>y</strong>:</p>
<p><img alt="missing image" src="../../../../_images/FIR_Equation.jpg"/></p>
<p>DSP experts may say that this equation represents a <em>correlation</em> and not a <em>convolution</em> which is the mathematical expression of the filtering operation. The easy answer may be to say that it is simply a question of coefficients ordering (and perhaps conjugation for complex coefficients).</p>
<p>That’s why you will always see at the beginning of the various <em>graph.h</em> files the 2 lines:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cint16</span><span class="o">&gt;</span> <span class="n">taps</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cint16</span><span class="o">&gt;</span><span class="p">({</span>
  <span class="p">...</span>
<span class="p">});</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cint16</span><span class="o">&gt;</span> <span class="n">taps_aie</span><span class="p">(</span><span class="n">taps</span><span class="p">.</span><span class="n">rbegin</span><span class="p">(),</span><span class="n">taps</span><span class="p">.</span><span class="n">rend</span><span class="p">());</span>
</pre></div>
</div>
<p>The first line is the taps vector definition in the correct order for a DSP expert, and the second line defines the vector that will be used in the AI Engine implementation as the same vector but in the reverse order.</p>
<p><a name="UtilsDirectory"></a></p>
<h2>“Utils” Directory</h2>
<p>For this tutorial a number of utilities have been created that you are free to reuse for your own purposes.</p>
<p>First, to allow these utilities to be called from anywhere during this tutorial you need to add this directory in your <strong><em>PATH</em></strong> but also indicate to <code class="docutils literal notranslate"><span class="pre">python</span></code> that this directory contains some libraries and should be checked during imports.</p>
<p>Navigate to the <code class="docutils literal notranslate"><span class="pre">Utils</span></code> directory, and type <code class="docutils literal notranslate"><span class="pre">source</span> <span class="pre">InitPythonPath</span></code> to have this directory in your path for Python libraries and executable search path.</p>
<h3>GenerateStreams</h3>
<p>This utility will use a library <strong><em>GenerationLib.py</em></strong> to generate input data suitable for the cases you want to test. It is called by typing: <code class="docutils literal notranslate"><span class="pre">GenerateStreamsGUI</span></code>. This displays a GUI in which you can select the appropriate parameters to generate the correct input data files:</p>
<p><img alt="missing image" src="../../../../_images/GenerateStreams.jpg"/></p>
<p>You have access to a number of parameters:</p>
<ul class="simple">
<li><p><em>Data Type</em>: by default <code class="docutils literal notranslate"><span class="pre">cint16</span></code>as this is what you will use throughout this tutorial</p></li>
<li><p><em>PLIO Width</em>: by default <code class="docutils literal notranslate"><span class="pre">64</span></code> as this is the width which is used in this tutorial</p></li>
<li><p><em>Number of Phases</em>: for Super Sampling Rate Filters</p></li>
<li><p><em>Number of Streams</em>: for the SSR filters using the 2 streams of the AI Engines</p></li>
<li><p><em>Number of Samples per Stream per Phase</em>: Each stream contains a number of samples defined there</p></li>
<li><p><em>Number of Frames</em>: simulations are launched for a limited number of Frames</p></li>
<li><p><em>Base of the Filename</em>: <code class="docutils literal notranslate"><span class="pre">PhaseIn</span></code> by default which generates the following names:</p>
<ul>
<li><p>Single Stream, Single Phase: <code class="docutils literal notranslate"><span class="pre">PhaseIn_0.txt</span></code></p></li>
<li><p>Single Stream, Polyphase: <code class="docutils literal notranslate"><span class="pre">PhaseIn_0.txt</span></code>, <code class="docutils literal notranslate"><span class="pre">PhaseIn_1.txt</span></code>, …</p></li>
<li><p>Dual streams, Polyphase:  <code class="docutils literal notranslate"><span class="pre">PhaseIn_0_0.txt</span></code>, <code class="docutils literal notranslate"><span class="pre">PhaseIn_0_0.txt</span></code>, <code class="docutils literal notranslate"><span class="pre">PhaseIn_1_0.txt,</span> </code>PhaseIn_1_0.txt``, …</p></li>
</ul>
</li>
</ul>
<p>Another possibility is to type <code class="docutils literal notranslate"><span class="pre">GenerateStreams</span></code> with the same parameters. If you type <code class="docutils literal notranslate"><span class="pre">GenerateStreams</span></code> without parameters, a usage text will be displayed:</p>
<div class="highlight-BASH notranslate"><div class="highlight"><pre><span></span>&gt;&gt;GenerateStreams

Stream Content <span class="nv">Generation</span>

<span class="o">================================================================================================</span>

Usage:
GenerateStreams DataType PLIO_Width NPhases NStreams NSamples NFrames SequenceType Basename
   Datatype: cint16, int16, int32
   PLIO_Width: <span class="m">32</span>, <span class="m">64</span> or <span class="m">128</span>
   NPhases: any integer &gt;<span class="o">=</span> <span class="m">1</span>
   NStreams: <span class="m">1</span> or <span class="m">2</span>
   NSamples: integer, multiple of <span class="m">8</span>
   NFrames: Any integer &gt;<span class="o">=</span> <span class="m">1</span>
   SequenceType: Dirac, Linear, SinCos, Random
   Basename: file name that will prepend phase and stream <span class="nv">index</span>

<span class="o">================================================================================================</span>
</pre></div>
</div>
<h2>ProcessAIEOutput</h2>
<p>This utility takes all generated outputs and displays the reconstructed signal. For Single Stream/Single Phase it will display a signal using the timestamps written in the file.</p>
<p>If your output signals are stored in files named <code class="docutils literal notranslate"><span class="pre">output_0.txt</span></code> … then navigate to the output directory and type <code class="docutils literal notranslate"><span class="pre">ProcessAIEOutput</span> <span class="pre">output_*</span></code> to process the output of the AI Engines.</p>
<p>Two other files are generated:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Atot.txt</span></code> which is the output phase by phase</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">out.txt</span></code> which is the textfile of the reconstructed signal</p></li>
</ul>
<h3>StreamThroughput</h3>
<p>This utility computes the throughput concerning all AI Engine output files given in an argument.</p>
<h3>GetDeclare.sh</h3>
<p>This utility has been created to view the template arguments that were used for kernel declaration in the Double Stream SSR case. It can be easily modified to be adapted to different cases.</p>
<p align="center" class="sphinxhide"><sup>Copyright© 2020–2021 Xilinx</sup><br/><sup>XD020</sup></p>
<footer>
<!-- Atalwar: Moved the footer code to layout.html to resolve conflict with the Xilinx template -->
</footer>
</div>