
<table class="sphinxhide" width="100%">
<tr width="100%">
<td align="center"><img src="https://raw.githubusercontent.com/Xilinx/Image-Collateral/main/xilinx-logo.png" width="30%"/>
<a href="https://www.xilinx.com/products/design-tools/vitis.html">See Vitis™ Development Environment on xilinx.com</a>
<a href="https://www.xilinx.com/products/design-tools/vitis/vitis-ai.html">See Vitis-AI™ Development Environment on xilinx.com</a>
</td>
</tr>
</table>
<p>In this second part of the tutorial you will dispatch the computations over multiple AI Engines and analyze the performances that can be achieved.</p>
<p>Navigate to the <code class="docutils literal notranslate"><span class="pre">MultiKernel</span></code> directory to continue.</p>
<h2>Designing the Kernel</h2>
<p>As in the Single-kernel tutorial, this design will use streaming input and output but the performances must be improved. Limitations can come from two sources:</p>
<ul class="simple">
<li><p>Limit on the bandwidth side</p></li>
<li><p>Limit in the compute performance side</p></li>
</ul>
<p>In the single-kernel section of the tutorial the maximum throughput was 225 Msps, which shows that the streams are starved due to a limitation of the compute performance. The data type <code class="docutils literal notranslate"><span class="pre">cint16</span></code> is 32-bit wide and the maximum bandwidth of the AXI-Stream connection array is 1x <code class="docutils literal notranslate"><span class="pre">cint16</span></code> per clock cycle on a single stream. In the single-kernel part, four of them were read in four clock cycles, but the computation was taking 16 clock cycles for the 32 taps. For the optimal trade-off, the computation should take only four clock cycles for each of the four input samples read from the stream. In four clock cycles, eight taps can be processed, the complete filtering operation should be split onto four AI Engines.</p>
<p>The Single-Kernel Filter can be represented by this convolution:</p>
<p><img alt="missing image" src="../../../../../_images/FourKernelDivision_1.jpg"/></p>
<p>After subdivision into four Kernels, each one on a different AI Engine, the filter can be represented by four smaller filters in parallel running on the same data stream, except that for some of these kernels the beginning of the stream is discarded:</p>
<p><img alt="missing image" src="../../../../../_images/FourKernelDivision_2.jpg"/></p>
<p>The four AI Engines each perform the computations for a subset of the coefficients. Their results must be added together to get the overall result. The AI Engine architecture allows a number of accumulators to be sent to a neighboring AI Engine to be used as a starting point for a number of <code class="docutils literal notranslate"><span class="pre">mac</span></code> operations. For computations being performed on four lanes, the accumulator vector is <code class="docutils literal notranslate"><span class="pre">v4cacc48</span></code>, which is a 384 bit vector that can be sent to the next AI Engine in the chain in one clock cycle.</p>
<p><img alt="missing image" src="../../../../../_images/FourKernels.jpg"/></p>
<h2>C++ Code Analysis</h2>
<p>As shown in the previous figure, there are three different types of kernels that differ from their interface:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th align="left">Location</th>
<th align="center">Inputs</th>
<th align="right">Output</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">First block</td>
<td align="center">Stream In</td>
<td align="right">Cascade Out</td>
</tr>
<tr>
<td align="left">Middle Block</td>
<td align="center">Stream In<br/>Cascade In</td>
<td align="right">Cascade Out</td>
</tr>
<tr>
<td align="left">Last Block</td>
<td align="center">Stream In<br/>Cascade In</td>
<td align="right">Stream Out</td>
</tr>
</tbody>
</table><p>They have been named with respect to their cascade connection structure:</p>
<ul class="simple">
<li><p>FIR_MultiKernel_cout</p></li>
<li><p>FIR_MultiKernel_cincout</p></li>
<li><p>FIR_MultiKernel_cincout</p></li>
</ul>
<p>The class declaration for the first one is:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">NSamples</span><span class="p">,</span><span class="kt">int</span> <span class="n">ShiftAcc</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">FIR_MultiKernel_cout</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
	<span class="k">alignas</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span> <span class="n">cint16</span> <span class="n">weights</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="k">alignas</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span> <span class="n">cint16</span> <span class="n">delay_line</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

<span class="k">public</span><span class="o">:</span>
	<span class="n">FIR_MultiKernel_cout</span><span class="p">(</span><span class="k">const</span> <span class="n">cint16</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">taps</span><span class="p">)[</span><span class="mi">8</span><span class="p">])</span>
	<span class="p">{</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">taps</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">16</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">delay_line</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">cint16</span><span class="p">){</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span>
	<span class="p">};</span>

	<span class="kt">void</span> <span class="nf">filter</span><span class="p">(</span><span class="n">input_stream_cint16</span><span class="o">*</span>  <span class="n">sin</span><span class="p">,</span><span class="n">output_stream_cacc48</span><span class="o">*</span>  <span class="n">cout</span><span class="p">);</span>

	<span class="k">static</span> <span class="kt">void</span> <span class="nf">registerKernelClass</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">REGISTER_FUNCTION</span><span class="p">(</span><span class="n">FIR_MultiKernel_cout</span><span class="o">::</span><span class="n">filter</span><span class="p">);</span>
	<span class="p">};</span>
<span class="p">};</span>
</pre></div>
</div>
<h3>Data and Coefficients Management and Operation Scheduling</h3>
<p>The difference between the single-kernel case and this case is that the tap array contains eight elements and that the delay line is only 16 element deep. In the previous section you saw that there were only two <code class="docutils literal notranslate"><span class="pre">mul4</span></code> and <code class="docutils literal notranslate"><span class="pre">mac4</span></code> intrinsics for cint16 x cint16 operations.</p>
<p><img alt="missing image" src="../../../../../_images/Mul4Intrinsics.jpg"/></p>
<p>More interestingly is the one that uses a <code class="docutils literal notranslate"><span class="pre">v16cint16</span></code> for the data register. Filter output compute for an eight tap filter on four lanes in parallel requires (8+3 = 11) data in the buffer. The delay-line should contain at least eight samples as the seven previous samples will be needed for the computation of the first output.</p>
<p>The following image gives an idea of data update scheduling and how it is interleaved with <code class="docutils literal notranslate"><span class="pre">mul4</span></code>/<code class="docutils literal notranslate"><span class="pre">mac4</span></code> operations (only the first eight outputs).</p>
<p><img alt="missing image" src="../../../../../_images/Scheduling8tapFilter.jpg"/></p>
<p>The related C++ code is as follows:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">SingleStream</span><span class="o">::</span><span class="n">FIR_MultiKernel_cout</span><span class="o">&lt;</span><span class="n">NSamples</span><span class="p">,</span><span class="n">ShiftAcc</span><span class="o">&gt;::</span><span class="n">filter</span><span class="p">(</span><span class="n">input_stream_cint16</span><span class="o">*</span> <span class="n">sin</span><span class="p">,</span><span class="n">output_stream_cacc48</span><span class="o">*</span> <span class="n">cout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">v8cint16</span> <span class="n">taps</span> <span class="o">=</span>  <span class="o">*</span><span class="p">(</span><span class="n">v8cint16</span><span class="o">*</span><span class="p">)</span> <span class="n">weights</span><span class="p">;</span>
	<span class="n">v16cint16</span> <span class="o">*</span><span class="n">ptr_delay_line</span> <span class="o">=</span> <span class="p">(</span><span class="n">v16cint16</span> <span class="o">*</span><span class="p">)</span><span class="n">delay_line</span><span class="p">;</span>
	<span class="n">v16cint16</span> <span class="n">data</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr_delay_line</span><span class="p">;</span>

	<span class="n">v4cacc48</span> <span class="n">acc</span> <span class="o">=</span> <span class="n">undef_v4cacc48</span><span class="p">();</span>



<span class="c1">// Computes 16 samples per iteration</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">NSamples</span><span class="o">/</span><span class="mi">16</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">chess_prepare_for_pipelining</span>
		<span class="n">chess_loop_range</span><span class="p">(</span><span class="n">NSamples</span><span class="o">/</span><span class="mi">16</span><span class="p">,</span><span class="n">NSamples</span><span class="o">/</span><span class="mi">16</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">acc</span> <span class="o">=</span> <span class="n">mul4</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mh">0x3210</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">taps</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">acc</span> <span class="o">=</span> <span class="n">mac4</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mh">0x3210</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">taps</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">upd_v</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">readincr_v4</span><span class="p">(</span><span class="n">sin</span><span class="p">));</span>
		<span class="n">acc</span> <span class="o">=</span> <span class="n">mac4</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mh">0x3210</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">taps</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">acc</span> <span class="o">=</span> <span class="n">mac4</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mh">0x3210</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">taps</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">writeincr_v4</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span><span class="n">acc</span><span class="p">);</span>

		<span class="n">acc</span> <span class="o">=</span> <span class="n">mul4</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mh">0x3210</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">taps</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">acc</span> <span class="o">=</span> <span class="n">mac4</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mh">0x3210</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">taps</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">upd_v</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">readincr_v4</span><span class="p">(</span><span class="n">sin</span><span class="p">));</span>
		<span class="n">acc</span> <span class="o">=</span> <span class="n">mac4</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mh">0x3210</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">taps</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">acc</span> <span class="o">=</span> <span class="n">mac4</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mh">0x3210</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">taps</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">writeincr_v4</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span><span class="n">acc</span><span class="p">);</span>

		<span class="n">acc</span> <span class="o">=</span> <span class="n">mul4</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mh">0x3210</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">taps</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">acc</span> <span class="o">=</span> <span class="n">mac4</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mh">0x3210</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">taps</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">upd_v</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">readincr_v4</span><span class="p">(</span><span class="n">sin</span><span class="p">));</span>
		<span class="n">acc</span> <span class="o">=</span> <span class="n">mac4</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mh">0x3210</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">taps</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">acc</span> <span class="o">=</span> <span class="n">mac4</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mh">0x3210</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">taps</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">writeincr_v4</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span><span class="n">acc</span><span class="p">);</span>

		<span class="n">acc</span> <span class="o">=</span> <span class="n">mul4</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mh">0x3210</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">taps</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">acc</span> <span class="o">=</span> <span class="n">mac4</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mh">0x3210</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">taps</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">upd_v</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">readincr_v4</span><span class="p">(</span><span class="n">sin</span><span class="p">));</span>
		<span class="n">acc</span> <span class="o">=</span> <span class="n">mac4</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mh">0x3210</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">taps</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">acc</span> <span class="o">=</span> <span class="n">mac4</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mh">0x3210</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">taps</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mh">0x0000</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">writeincr_v4</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span><span class="n">acc</span><span class="p">);</span>

	<span class="p">}</span>

	<span class="o">*</span><span class="n">ptr_delay_line</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This code is the one of <code class="docutils literal notranslate"><span class="pre">FIR_MultiKernel_cout</span></code>, the output is sent to the cascade stream using the <code class="docutils literal notranslate"><span class="pre">writeincr_v4(cout,acc)</span></code> instruction.</p>
<p>At the graph level, all kernels are first declared in a class:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">FIRGraph_4Kernels</span><span class="o">:</span> <span class="k">public</span> <span class="n">adf</span><span class="o">::</span><span class="n">graph</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
	<span class="n">kernel</span> <span class="n">k</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

<span class="k">public</span><span class="o">:</span>
	<span class="n">input_port</span> <span class="n">in</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">output_port</span> <span class="n">out</span><span class="p">;</span>
</pre></div>
</div>
<p>The constructor takes charge of the next operations. The first operation is to create the kernels: 1x<strong>FIR_MultiKernel_cout</strong>, 2x<strong>FIR_MultiKernel_cincout</strong>, 1x<strong>FIR_MultiKernel_cin</strong></p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">FIRGraph_4Kernels</span><span class="p">()</span>
<span class="p">{</span>

    <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">::</span><span class="n">create_object</span><span class="o">&lt;</span><span class="n">SingleStream</span><span class="o">::</span><span class="n">FIR_MultiKernel_cout</span><span class="o">&lt;</span><span class="n">NUM_SAMPLES</span><span class="p">,</span><span class="n">SHIFT</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">taps4_0</span><span class="p">);</span>
    <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">::</span><span class="n">create_object</span><span class="o">&lt;</span><span class="n">SingleStream</span><span class="o">::</span><span class="n">FIR_MultiKernel_cincout</span><span class="o">&lt;</span><span class="n">NUM_SAMPLES</span><span class="p">,</span><span class="n">SHIFT</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">taps4_1</span><span class="p">);</span>
    <span class="n">k</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">::</span><span class="n">create_object</span><span class="o">&lt;</span><span class="n">SingleStream</span><span class="o">::</span><span class="n">FIR_MultiKernel_cincout</span><span class="o">&lt;</span><span class="n">NUM_SAMPLES</span><span class="p">,</span><span class="n">SHIFT</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">taps4_2</span><span class="p">);</span>
    <span class="n">k</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">::</span><span class="n">create_object</span><span class="o">&lt;</span><span class="n">SingleStream</span><span class="o">::</span><span class="n">FIR_MultiKernel_cin</span><span class="o">&lt;</span><span class="n">NUM_SAMPLES</span><span class="p">,</span><span class="n">SHIFT</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">taps4_3</span><span class="p">);</span>
</pre></div>
</div>
<p>The AI Engine compiler needs to know the location of the source code for the kernels:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">int</span> <span class="n">NChunks</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">NChunks</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">runtime</span><span class="o">&lt;</span><span class="n">ratio</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">;</span>
        <span class="n">source</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">=</span> <span class="s">"aie_kernels/FirSingleStream.cpp"</span><span class="p">;</span>
        <span class="n">headers</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">=</span> <span class="p">{</span><span class="s">"aie_kernels/FirSingleStream.h"</span><span class="p">};</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>To shorten the place time by a few seconds, you can constrain the core location. A single one is necessary because all the others will be constrained by the <strong>cascade</strong> connection:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Constraints: location of the first kernel in the cascade</span>
<span class="n">location</span><span class="o">&lt;</span><span class="n">kernel</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">=</span> <span class="n">tile</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>All the kernels need to discard a specific number of elements. This will be handled by the initialization function as this must be done beforehand and only once:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Discard first elements of the stream, depending on position in the cascade</span>
<span class="n">initialization_function</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">=</span> <span class="s">"SingleStream::FIRinit&lt;0&gt;"</span><span class="p">;</span>
<span class="n">initialization_function</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">=</span> <span class="s">"SingleStream::FIRinit&lt;8&gt;"</span><span class="p">;</span>
<span class="n">initialization_function</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">=</span> <span class="s">"SingleStream::FIRinit&lt;16&gt;"</span><span class="p">;</span>
<span class="n">initialization_function</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">=</span> <span class="s">"SingleStream::FIRinit&lt;24&gt;"</span><span class="p">;</span>
</pre></div>
</div>
<p>Finally, all kernels must be connected together. This is done at the end of the constructor of the class:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Cascade Connections and output connection</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">NChunks</span><span class="mi">-1</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">connect</span><span class="o">&lt;</span><span class="n">cascade</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">in</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="n">connect</span><span class="o">&lt;</span><span class="n">stream</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="n">NChunks</span><span class="mi">-1</span><span class="p">].</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">out</span><span class="p">);</span>

<span class="c1">// Input Streams connections</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">NChunks</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">connect</span><span class="o">&lt;</span><span class="n">stream</span><span class="o">&gt;</span><span class="p">(</span><span class="n">in</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">in</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</pre></div>
</div>
<p>The initialization function is very simple. It simply reads data from the input stream. Because there is no argument, the raw API for stream access must be used:</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">Delay</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">SingleStream</span><span class="o">::</span><span class="n">FIRinit</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Delay</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">get_ss</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<h2>Compilation and Analysis</h2>
<p>Ensure that the <code class="docutils literal notranslate"><span class="pre">InitPythonPath</span></code> has been sourced in the <code class="docutils literal notranslate"><span class="pre">Utils</span></code> directory.</p>
<p>Navigate to the <code class="docutils literal notranslate"><span class="pre">MultiKernel</span></code> directory. In the <code class="docutils literal notranslate"><span class="pre">Makefile</span></code> three methods are defined:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">aie</span></code></p>
<ul>
<li><p>Compiles the graph and the kernels</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">aiesim</span></code></p>
<ul>
<li><p>Runs the AI Engine System C simulator</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">aieviz</span></code></p>
<ul>
<li><p>Runs <code class="docutils literal notranslate"><span class="pre">vitis_analyzer</span></code> on the output summary</p></li>
</ul>
</li>
</ul>
<p>Have a look at the source code (kernel and graph) to familiarize yourself with the C++ instantiation of kernels. In <code class="docutils literal notranslate"><span class="pre">graph.cpp</span></code> the PL AI Engine connections are declared using 64-bit interfaces running at 500 MHz, allowing for maximum bandwidth on the AI Engine array AXI-Stream network.</p>
<p>To have the simulation running, input data must be generated. There are 2 possibilities:</p>
<ol class="simple">
<li><p>Just type <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">data</span></code></p></li>
<li><p>Change directory to <code class="docutils literal notranslate"><span class="pre">data</span></code> and type <code class="docutils literal notranslate"><span class="pre">GenerateStreams</span></code>. The following parameters should be set for this example:</p></li>
</ol>
<p><img alt="missing image" src="../../../../../_images/GenerateSingleStream.jpg"/></p>
<p>Click <strong>Generate</strong> then <strong>Exit</strong>. The generated file <code class="docutils literal notranslate"><span class="pre">PhaseIn_0.txt</span></code> should contain mainly 0’s, with a few 1’s and 10’s.</p>
<p>Type <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">all</span></code> and wait for <code class="docutils literal notranslate"><span class="pre">vitis_analyzer</span></code> GUI to display. The Vitis analyzer is able to show the graph, how it has been implemented in the device, and the complete timeline of the simulation. In this specific case the graph is very simple (a single kernel) and the implementation is on a single AI Engine.</p>
<p>Click <strong>Graph</strong> to visualize the graph of the application:</p>
<p><img alt="missing image" src="../../../../../_images/Graph4Kernels.jpg"/></p>
<p>The four kernels and their four independent input streams are clearly visible. A single input with a FIFO of eight between each AI Engine can also be implemented.</p>
<p>Click <strong>Array</strong> to visualize where the kernel has been placed, and how it is fed from the the PL:</p>
<p><img alt="missing image" src="../../../../../_images/Array4Kernels.jpg"/></p>
<p>In this view the cascade streams connecting neighboring AI Engines are key to the performance of this graph.</p>
<p>Finally click <strong>Trace</strong> to look at how the entire simulation went through. This may be useful to track where your AI Engine stalls if performance is not as expected:</p>
<p><img alt="missing image" src="../../../../../_images/Timeline4Kernels.jpg"/></p>
<p>Now the output of the filter can be displayed. The input being a set of Dirac impulses, the impulse response of the filter should be recognized throughout the waveform. Navigate to <code class="docutils literal notranslate"><span class="pre">Emulation-AIE/aiesimulator_output/data</span></code> and look at the <code class="docutils literal notranslate"><span class="pre">Output_0.txt</span></code>. You can see that you have two complex outputs per line which is prepended with a time stamp.  <code class="docutils literal notranslate"><span class="pre">ProcessAIEOutput</span> <span class="pre">Output_0.txt</span></code>.</p>
<p><img alt="missing image" src="../../../../../_images/GraphOutput4Kernels.jpg"/></p>
<p>The top graph reflects the outputs where the abscissa is the time at which this output occured. The four frames are clearly localized; there is no output for a number of clock cycles. On the bottom graph, a zoom on the output is displayed and the filter impulse response is recognizable.</p>
<p>The performance of this architecture can be measured using the timestamped output. In the same directory (<code class="docutils literal notranslate"><span class="pre">Emulation-AIE/aiesimulator_output/data</span></code>) type <code class="docutils literal notranslate"><span class="pre">StreamThroughput</span> <span class="pre">Output_0.txt</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Output_0</span><span class="o">.</span><span class="n">txt</span> <span class="o">--&gt;</span>   <span class="mf">951.67</span> <span class="n">Msps</span>

<span class="o">-----------------------</span>


<span class="n">Total</span> <span class="n">Throughput</span> <span class="o">--&gt;</span>     <span class="mf">951.67</span> <span class="n">Msps</span>
</pre></div>
</div>
<p>This architecture achieves very close to 1 Gsps performance. It is slightly less because of the number of cycles spent for initialization when the kernels are called (the quiet zones in the output graph). This performance increases when the frame length is increased.</p>
<p align="center"><sup>Copyright© 2020–2021 Xilinx</sup><br/><sup>XD020</sup></p>
<footer>
<!-- Atalwar: Moved the footer code to layout.html to resolve conflict with the Xilinx template -->
</footer>
