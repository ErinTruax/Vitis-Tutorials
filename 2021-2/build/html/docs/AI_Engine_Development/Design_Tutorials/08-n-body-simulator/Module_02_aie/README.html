
<table class="sphinxhide" width="100%">
<tr width="100%">
<td align="center"><img src="https://raw.githubusercontent.com/Xilinx/Image-Collateral/main/xilinx-logo.png" width="30%"/>
<a href="https://www.xilinx.com/products/design-tools/vitis.html">See Vitis™ Development Environment on xilinx.com</a>
<a href="https://www.xilinx.com/products/design-tools/vitis/vitis-ai.html">See Vitis-AI™ Development Environment on xilinx.com</a>
</td>
</tr>
</table>
<p><em>Estimated time: 2 hours</em></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">aie</span>
</pre></div>
</div>
<p>or</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">aiecompiler</span> <span class="o">-</span><span class="n">v</span>  <span class="o">--</span><span class="n">target</span><span class="o">=</span><span class="n">hw</span> 					\
                <span class="o">--</span><span class="n">stacksize</span><span class="o">=</span><span class="mi">2000</span> 				\
                <span class="o">-</span><span class="n">include</span><span class="o">=</span><span class="s2">"$(XILINX_VITIS)/aietools/include"</span> 	\
	        <span class="o">-</span><span class="n">include</span><span class="o">=</span><span class="s2">"./"</span> 					\
	        <span class="o">-</span><span class="n">include</span><span class="o">=</span><span class="s2">"./src"</span> 				\
	        <span class="o">-</span><span class="n">include</span><span class="o">=</span><span class="s2">"../data"</span> 				\
	        <span class="n">nbody_x4_100</span><span class="o">.</span><span class="n">cpp</span> 				\
	        <span class="o">-</span><span class="n">workdir</span><span class="o">=</span><span class="n">work</span>
</pre></div>
</div>
<h2>AI Engine Design</h2>
<p>The following AI Engine features are used in this design:</p>
<ul class="simple">
<li><p>single precision floating-point compute of the N-Body gravity equations on 12,800 particles</p></li>
<li><p>400 tile design with 400 parallel accelerators</p></li>
<li><p>1:400 broadcast stream</p></li>
<li><p>1:4 packet split</p></li>
<li><p>4:1 packet merge</p></li>
<li><p>PL Kernels designed to support packet switching in AI Engine</p></li>
</ul>
<h2>A Single Nbody() Kernel</h2>
<p>Review the <code class="docutils literal notranslate"><span class="pre">src/nbody.cc</span></code> file. It contains the implementation of a single AI Engine kernel mapped to a single AI Engine tile called <code class="docutils literal notranslate"><span class="pre">nbody()</span></code>. This kernel takes in the <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">y</span> <span class="pre">z</span> <span class="pre">vx</span> <span class="pre">vy</span> <span class="pre">vz</span> <span class="pre">m</span></code> values for 32 particles, computes the N-Body gravity equations for a single timestep, and outputs the new <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">y</span> <span class="pre">z</span> <span class="pre">vx</span> <span class="pre">vy</span> <span class="pre">vz</span> <span class="pre">m</span></code> values for the 32 particles. This kernel takes in two inputs: <code class="docutils literal notranslate"><span class="pre">w_input_i</span></code> and <code class="docutils literal notranslate"><span class="pre">w_input_j</span></code>. The <code class="docutils literal notranslate"><span class="pre">w_input_i</span></code> window contains the <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">y</span> <span class="pre">z</span> <span class="pre">vx</span> <span class="pre">vy</span> <span class="pre">vz</span> <span class="pre">m</span></code> floating point values for 32 particles. The <code class="docutils literal notranslate"><span class="pre">w_input_j</span></code> window contains the only <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">y</span> <span class="pre">z</span> <span class="pre">m</span></code> floating-point values for the same 32 particles. This kernel produces one output: <code class="docutils literal notranslate"><span class="pre">w_output_i</span></code> which contains the new <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">y</span> <span class="pre">z</span> <span class="pre">vx</span> <span class="pre">vy</span> <span class="pre">vz</span> <span class="pre">m</span></code> floating-point values for the 32 particles in the next timestep.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>name</th>
<th>number of 32-bit data values</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>w_input_i</code></td>
<td>32 * 7 = 224</td>
</tr>
<tr>
<td><code>w_input_j</code></td>
<td>32 * 4 = 128</td>
</tr>
<tr>
<td><code>w_output_i</code></td>
<td>32 * 7 = 224</td>
</tr>
</tbody>
</table><p><img alt="alt text" src="../../../../../_images/data_formats.png"/></p>
<p>The <code class="docutils literal notranslate"><span class="pre">nbody()</span></code> kernel is sectioned into two major <code class="docutils literal notranslate"><span class="pre">for</span></code> loops. The first major <code class="docutils literal notranslate"><span class="pre">for</span></code> loop (around lines 38-61) calculates the new <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">y</span> <span class="pre">z</span></code> positions for the 32 particles. The second major <code class="docutils literal notranslate"><span class="pre">for</span></code> loop (around lines 64-202) calculates the new <code class="docutils literal notranslate"><span class="pre">vx</span> <span class="pre">vy</span> <span class="pre">vz</span></code> velocities for the 32 particles. The output mass (<code class="docutils literal notranslate"><span class="pre">m</span></code>) values remain the same as the inputs. The <code class="docutils literal notranslate"><span class="pre">w_output_i</span></code> window is then sent to the <code class="docutils literal notranslate"><span class="pre">transmit_new_i</span></code> kernel (source: <code class="docutils literal notranslate"><span class="pre">src/transmit_new_i.cc</span></code>) to be written to the final output window.</p>
<h2>Four NBody() Kernels Packet Switched</h2>
<p>Next, review the <code class="docutils literal notranslate"><span class="pre">src/nbody_subsystem.h</span></code> graph. This graph creates four N-Body kernels, a packet splitter kernel, and a packet merger kernel. Review the packet switching feature tutorial to learn more about the packet switching feature in the AI Engine: <a class="reference external" href="https://github.com/Xilinx/Vitis-Tutorials/tree/master/AI_Engine_Development/Feature_Tutorials/04-packet-switching">04-packet-switching</a>.</p>
<p><img alt="alt text" src="docs/AI_Engine_Development/Design_Tutorials/08-n-body-simulator/Module_02_aie/images/nbody_subsystem%20(1).PNG"/></p>
<p>The <code class="docutils literal notranslate"><span class="pre">nbody_subsystem</span></code> graph has two inputs: <code class="docutils literal notranslate"><span class="pre">input_i</span></code> and <code class="docutils literal notranslate"><span class="pre">input_j</span></code>. The <code class="docutils literal notranslate"><span class="pre">input_i</span></code> port is a packet stream that connects to the packet splitter. The packet splitter redirects packets of data to the <code class="docutils literal notranslate"><span class="pre">w_input_i</span></code> port of each <code class="docutils literal notranslate"><span class="pre">nbody()</span></code> kernel. Each <code class="docutils literal notranslate"><span class="pre">input_i</span></code> packet contains a packet header, 224 32-bit data values, and TLAST asserted with the <code class="docutils literal notranslate"><span class="pre">m31</span></code> data value. The <code class="docutils literal notranslate"><span class="pre">input_j</span> </code> port is a data stream that is broadcast to all the <code class="docutils literal notranslate"><span class="pre">nbody()</span></code> kernels (i.e., all <code class="docutils literal notranslate"><span class="pre">nbody()</span></code> kernels receive the same <code class="docutils literal notranslate"><span class="pre">input_j</span></code> data). The <code class="docutils literal notranslate"><span class="pre">nbody()</span></code> kernels perform their computations and generate the new <code class="docutils literal notranslate"><span class="pre">w_output_i</span></code> data which is merged into a single stream of packets, resulting in the output of the <code class="docutils literal notranslate"><span class="pre">nbody_subsystem</span></code> graph <code class="docutils literal notranslate"><span class="pre">output_i</span></code>.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Name</th>
<th>Number of 32-bit Data Values</th>
<th>Window Size (bytes)</th>
</tr>
</thead>
<tbody>
<tr>
<td>input_i</td>
<td>224 * 4 = 896</td>
<td>896 * 4 = 3584 bytes</td>
</tr>
<tr>
<td>input_j</td>
<td>128</td>
<td>128 * 4 = 512 bytes</td>
</tr>
<tr>
<td>output_i</td>
<td>224 * 4 = 896</td>
<td>896 * 4 = 3584 bytes</td>
</tr>
</tbody>
</table><p>A single instance of the <code class="docutils literal notranslate"><span class="pre">nbody_subsystem</span></code> graph can simulate 128 particles using four AI Engine tiles.</p>
<h3>Workload Distribution and input_j</h3>
<p>To calculate the N-Body gravity equations for 128 particles, each <code class="docutils literal notranslate"><span class="pre">nbody()</span></code> kernel calculates the N-Body gravity equations for 32 particles. However, in order to calculate acceleration and the new velocities, an <code class="docutils literal notranslate"><span class="pre">nbody()</span></code> kernel needs to know the data in the other kernels. For example, if particle 0 is mapped to <code class="docutils literal notranslate"><span class="pre">nbody_kernel[0]</span></code> and particle 32 is mapped to <code class="docutils literal notranslate"><span class="pre">nbody_kernel[1]</span></code>,  then <code class="docutils literal notranslate"><span class="pre">nbody_kernel[0]</span></code> needs to know the data in <code class="docutils literal notranslate"><span class="pre">nbody_kernel[1]</span></code> to accurately calculate the summation equation for acceleration and then calculate the new velocity of particle 0.</p>
<p>This is where the <code class="docutils literal notranslate"><span class="pre">input_j</span></code> stream plays a vital role in data sharing. Even though the <code class="docutils literal notranslate"><span class="pre">input_j</span></code> data stream has a window size for 32 particles worth of data, the <code class="docutils literal notranslate"><span class="pre">LOOP_COUNT_J</span></code> value can be set to allow the <code class="docutils literal notranslate"><span class="pre">nbody()</span></code> kernels to take in any number of 32 particles worth of data at a time. For a single instance of the <code class="docutils literal notranslate"><span class="pre">nbody_subsystem</span></code> graph, the <code class="docutils literal notranslate"><span class="pre">LOOP_COUNT_J</span></code> should be set to 4 to stream in data for all four kernels. For the final AI Engine graph, which contains 100 instances of the <code class="docutils literal notranslate"><span class="pre">nbody_subsystem</span></code> graph, the <code class="docutils literal notranslate"><span class="pre">LOOP_COUNT_J</span></code> value is set to 400 to stream in data for all 400 kernels to each <code class="docutils literal notranslate"><span class="pre">nbody()</span></code> kernel.</p>
<p><img alt="alt text" src="../../../../../_images/input_j_description.png"/></p>
<p>For example, to calculate the new velocity of particle 0 mapped in <code class="docutils literal notranslate"><span class="pre">nbody_kernel[0]</span></code>, the <code class="docutils literal notranslate"><span class="pre">nbody_kernel[0]</span></code> can retrieve the data value of particle 32 from the <code class="docutils literal notranslate"><span class="pre">input_j</span></code> stream. This way, all <code class="docutils literal notranslate"><span class="pre">nbody()</span></code> kernels will have the data values for all other particles mapped in the other <code class="docutils literal notranslate"><span class="pre">nbody()</span></code> kernels through data streaming from <code class="docutils literal notranslate"><span class="pre">input_j</span></code>.</p>
<h2>100 N-Body Subsystems</h2>
<p>Review the <code class="docutils literal notranslate"><span class="pre">nbody_x4_x100.h</span></code>. It contains the definition of the <code class="docutils literal notranslate"><span class="pre">nbodySystem</span></code> graph which contains 100 instances of the <code class="docutils literal notranslate"><span class="pre">nbody_subsystem</span></code> graph. Each <code class="docutils literal notranslate"><span class="pre">nbody_subsystem</span></code> is mapped to four AI Engine tiles which each contain an <code class="docutils literal notranslate"><span class="pre">nbody()</span></code> kernel. Therefore, the <code class="docutils literal notranslate"><span class="pre">nbodySystem</span></code> graph contains 400 <code class="docutils literal notranslate"><span class="pre">nbody()</span></code> kernels using up all of the 400 available AI Engine tiles. Since each <code class="docutils literal notranslate"><span class="pre">nbody()</span></code> kernel simulates 32 particles, the <code class="docutils literal notranslate"><span class="pre">nbodySystem</span></code> simulates 12,800 particles (32 particles * 400 kernels). There are 100 <code class="docutils literal notranslate"><span class="pre">input_i</span></code> ports (<code class="docutils literal notranslate"><span class="pre">input_i0-99</span></code>) and a single <code class="docutils literal notranslate"><span class="pre">input_j</span></code> port. For 1 iteration, the <code class="docutils literal notranslate"><span class="pre">input_i</span></code> ports receive 4 packetized <code class="docutils literal notranslate"><span class="pre">w_input_i</span></code> data which are distributed to 4 <code class="docutils literal notranslate"><span class="pre">nbody()</span></code> kernels in each <code class="docutils literal notranslate"><span class="pre">nbody_subsystem</span></code> graph. The <code class="docutils literal notranslate"><span class="pre">input_j</span></code> is a 1:400 broadcast stream to the 400 <code class="docutils literal notranslate"><span class="pre">w_input_j</span></code> ports in the 400 <code class="docutils literal notranslate"><span class="pre">nbody()</span></code> kernels.</p>
<p>Review the <code class="docutils literal notranslate"><span class="pre">nbody_x4_100.cpp</span></code> file. It contains an instance of the <code class="docutils literal notranslate"><span class="pre">nbodySystem</span></code> graph and simulates it for one iteration. Also, review the data files in the data folder where you will find the input data files for the <code class="docutils literal notranslate"><span class="pre">nbodySystem</span></code> (<code class="docutils literal notranslate"><span class="pre">input_i0-99.txt</span></code> and <code class="docutils literal notranslate"><span class="pre">input_j.txt</span></code>) used by the <code class="docutils literal notranslate"><span class="pre">nbodySystem</span></code> graph.</p>
<p><img alt="alt text" src="../../../../../_images/x100_design.png"/></p>
<p>Below is the implementation of the 100 compute unit on all 400 AI Engine tiles viewed on the Vitis Analyzer tool.
<img alt="alt text" src="../../../../../_images/aie_impl_1_cu_highlighted.PNG"/></p>
<p>The red highlighted region encompasses four AI Engine tiles which contain a single compute unit.</p>
<p>Following is the graph visualization of a single compute unit on the Vitis Analyzer tool.
<img alt="alt text" src="../../../../../_images/aie_single_cu.PNG"/></p>
<h2>Why Packet Switching?</h2>
<p>You might be curious about the need to implement the packet switching scheme 1:4/4:1. This was done to circumvent an AI Engine architecture limitation on the number of simultaneous input and output AXI-Streams allowed per AI Engine column. There are 50 AI Engine columns in the AI Engine array. Each column contains 8 AI Engine tiles. Each AI Engine column is allowed a maximum of 6 32-bit AXI-Stream inputs and 4 32-bit AXI-Stream outputs.</p>
<p>In the design, each <code class="docutils literal notranslate"><span class="pre">nbody()</span></code> kernel is mapped to an AI Engine tile. Meaning each column of 8 AI Engine tiles has 9 inputs streams and 8 output streams, violating these constraints.</p>
<ul class="simple">
<li><p>8 <code class="docutils literal notranslate"><span class="pre">w_input_i</span></code> input streams</p></li>
<li><p>1 <code class="docutils literal notranslate"><span class="pre">w_intput_j</span></code> input stream</p></li>
<li><p>8 <code class="docutils literal notranslate"><span class="pre">w_output_i</span></code> output streams</p></li>
</ul>
<p>With the 1:4/4:1 packet switching scheme, you can combine 4 streams into 1. Because packet switching is applied on the <code class="docutils literal notranslate"><span class="pre">w_input_i</span></code> ports, the number of input streams into a single AI Engine column is reduced to three:</p>
<ul class="simple">
<li><p>1 <code class="docutils literal notranslate"><span class="pre">input_i</span></code> stream that goes to tiles 0-3 in a column</p></li>
<li><p>1 <code class="docutils literal notranslate"><span class="pre">input_i</span></code> stream that goes to tiles 4-7 in a column</p></li>
<li><p>1 <code class="docutils literal notranslate"><span class="pre">input_j</span></code> stream that is broadcasted to all the columns</p></li>
</ul>
<p>On the output side, the number of output streams is reduced to two:</p>
<ul class="simple">
<li><p>1 <code class="docutils literal notranslate"><span class="pre">output_i</span></code> stream coming from tiles 0-3 in a column</p></li>
<li><p>1 <code class="docutils literal notranslate"><span class="pre">output_i</span></code> stream coming from tiles 4-7 in a column</p></li>
</ul>
<h2>(Optional) Simulate the AI Engine Design</h2>
<p><em>Estimated time: a few days</em></p>
<p>Run the following make command to invoke the aiesimulator.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">sim</span>
</pre></div>
</div>
<h2>References</h2>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/Xilinx/Vitis-Tutorials/tree/master/AI_Engine_Development/Feature_Tutorials/04-packet-switching">Packet Switching AI Engine Tutorial</a></p></li>
<li><p><a class="reference external" href="https://docs.xilinx.com/r/en-US/ug1076-ai-engine-environment/Explicit-Packet-Switching">AI Engine Documentation - Explicit Packet Switching</a></p></li>
<li><p><a class="reference external" href="https://docs.xilinx.com/r/en-US/ug1076-ai-engine-environment/Compiling-an-AI-Engine-Graph-Application">Compiling an AI Engine Graph Application</a></p></li>
<li><p><a class="reference external" href="https://docs.xilinx.com/r/en-US/ug1076-ai-engine-environment/Simulating-an-AI-Engine-Graph-Application">Simulating an AI Engine Graph Application</a></p></li>
</ul>
<h2>Next Steps</h2>
<p>After compiling the 100 compute unit N-Body Simulator design, you are ready to create the PL datamover kernels in the next module, <a class="reference external" href="../Module_03_pl_kernels">Module 03 - PL Design</a>.</p>
<p>GitHub issues will be used for tracking requests and bugs. For questions go to <a class="reference external" href="http://support.xilinx.com/">support.xilinx.com</a>.</p>
<p>Licensed under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License.</p>
<p>You may obtain a copy of the License at <a class="reference external" href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p align="center"> XD068 | © Copyright 2021 Xilinx, Inc.</p>
<footer>
<!-- Atalwar: Moved the footer code to layout.html to resolve conflict with the Xilinx template -->
</footer>
