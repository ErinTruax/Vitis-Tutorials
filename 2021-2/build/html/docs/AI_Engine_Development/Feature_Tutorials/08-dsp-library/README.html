<div class="rst-content">

<table class="sphinxhide" width="100%">
<tr width="100%">
<td align="center"><img src="https://raw.githubusercontent.com/Xilinx/Image-Collateral/main/xilinx-logo.png" width="30%"/>
<a href="https://www.xilinx.com/products/design-tools/vitis.html">See Vitis™ Development Environment on xilinx.com</a>
<a href="https://www.xilinx.com/products/design-tools/vitis/vitis-ai.html">See Vitis-AI™ Development Environment on xilinx.com</a>
</td>
</tr>
</table>
<p><em><strong>Version: Vitis 2021.2</strong></em></p>
<h2>Table of Contents</h2>
<ul class="simple">
<li><p><a class="reference external" href="#introduction">Introduction</a></p></li>
<li><p><a class="reference external" href="#before-you-begin">Before You Begin</a></p></li>
<li><p><a class="reference external" href="#part-1-creating-a-single-kernel-graph">Part 1: Creating a Single Kernel Graph</a></p></li>
<li><p><a class="reference external" href="#part-2-creating-a-multi-kernel-graph">Part 2: Creating a Multi Kernel Graph</a></p></li>
<li><p><a class="reference external" href="#part-3-optimizing-filter-performance">Part 3: Optimizing Filter Performance</a></p></li>
<li><p><a class="reference external" href="#references">References</a></p></li>
</ul>
<h2>Introduction</h2>
<p>The Xilinx® Versal™ adaptive compute acceleration platform (ACAP) is a fully software-programmable, heterogeneous compute platform that combines the processing system (PS) (Scalar Engines that include Arm® processors), Programmable Logic (PL) (Adaptable Engines that include the programmable logic), and AI Engines which belong in the Intelligent Engine category.</p>
<p>This tutorial demonstrates how to use kernels provided by the DSP Library for a filtering application, how to analyze the design results, and how to use filter parameters to optimize the design’s performance using simulation. It does not take the design to a hardware implementation, however.</p>
<h3>Objectives</h3>
<p>After completing the tutorial, you should be able to:</p>
<ul class="simple">
<li><p>Build signal processing datapath using the Vitis™ application acceleration development flow</p></li>
<li><p>Evaluate the performance and resource utilization metrics of a design</p></li>
<li><p>Adjust filter parameters to meet system performance requirements</p></li>
</ul>
<h3>Tutorial Overview</h3>
<p>This tutorial shows how to construct a simple two-stage decimation filter. This filter is not targeted at a specific real-life application, but is used to show how to use the DSP Library to construct filter chains.</p>
<ul class="simple">
<li><p>Part 1 shows how to use create an AI Engine project and instantiate a parameterized FIR filter from DSPLib</p></li>
<li><p>Part 2 shows how to cascade filters together into a chain</p></li>
<li><p>Part 3 shows how to optimize performance of the filter chain by tuning individual filters</p></li>
</ul>
<h3>Directory Structure</h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>dsplib_tutorial_install
├───images     images for this README
├───part_1
│   ├───data
│   └───src
├───part_2
│   ├───data
│   └───src
└───part_3
    ├───data
    └───src
</pre></div>
</div>
<h2>Before You Begin</h2>
<h3><em>Documentation</em>: Explore AI Engine Architecture</h3>
<ul class="simple">
<li><p><a class="reference external" href="https://forums.xilinx.com/t5/Design-and-Debug-Techniques-Blog/Versal-ACAP-AI-Engines-for-Dummies/ba-p/1132493">Versal ACAP AI Engines for Dummies</a></p></li>
<li><p><a class="reference external" href="https://www.xilinx.com/support/documentation/architecture-manuals/am009-versal-ai-engine.pdf">AM009 AI Engine Architecture Manual</a></p></li>
</ul>
<h3><em>Tools</em>: Installing the Tools</h3>
<p>Tools Documentation:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.xilinx.com/support/documentation/sw_manuals/xilinx2021_2/ug1076-ai-engine-environment.pdf">UG1076 Versal ACAP AI Engine Programming Environment</a></p></li>
<li><p><a class="reference external" href="https://xilinx.github.io/Vitis_Libraries/dsp/2021.2/index.html">Vitis DSP Library (DSPLib) Documentation</a></p></li>
</ul>
<p>To run through this tutorial, you will need to download and install the following tools:</p>
<ul class="simple">
<li><p>Install the <a class="reference external" href="https://docs.xilinx.com/r/en-US/ug1393-vitis-application-acceleration/Installation">Vitis Software Platform 2021.2</a></p></li>
<li><p>Obtain licenses for the AI Engine tools</p></li>
<li><p>Download the <a class="reference external" href="https://github.com/Xilinx/Vitis_Libraries/tree/master/dsp">DSP Library</a></p></li>
<li><p>Download and setup the <a class="reference external" href="https://www.xilinx.com/member/vck190_headstart.html#docs">VCK190 Vitis Platform for 2021.2</a></p></li>
</ul>
<h3><em>Environment</em>: Setting Up Your Target Platform Environment</h3>
<p>When the elements of the Vitis software platform are installed, update the target platform environment script.</p>
<p>Edit the provided template setup script <code class="docutils literal notranslate"><span class="pre">env_setup.sh</span></code> in your favourite text editor. Replace the placeholders with the appropriate paths:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1">#Setup environment variables </span>
<span class="nb">export</span> <span class="nv">PLATFORM_REPO_PATHS</span><span class="o">=</span>&lt;YOUR-PLATFORMS-DIRECTORY&gt;
<span class="nb">export</span> <span class="nv">DSPLIB_ROOT</span><span class="o">=</span>&lt;PATH-TO-DSP-LIBRARY&gt;
</pre></div>
</div>
<p>Then source the environment script:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">source</span> env_setup.sh
</pre></div>
</div>
<h3><em>Validation</em>: Confirming Tool Installation</h3>
<p>Ensure that you are using the 2021.1 version of Xilinx tools.</p>
<h2><em>Validation</em>: Confirming Tool Installation</h2>
<p>Ensure that you are using the 2021.2 version of Xilinx tools.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>which vitis
which aiecompiler
</pre></div>
</div>
<h3><em>Other Tutorials</em>: Learn Basic Vitis Compiler and AI Engine Concepts</h3>
<p>For novice users, following link provides tutorials to understand the basic Vitis compiler concepts and building simple AI Engine designs:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/Xilinx/Vitis-Tutorials">https://github.com/Xilinx/Vitis-Tutorials</a></p></li>
</ul>
<h2>Part 1: Creating a Single Kernel Graph</h2>
<p>Part 1 of this tutorial will:</p>
<ul class="simple">
<li><p>demonstrate how to create a Vitis project</p></li>
<li><p>link in the DSPLib functions</p></li>
<li><p>create a simple graph containing a parameterized DSPLib FIR filter.</p></li>
<li><p>compile and simulate the design</p></li>
<li><p>evaluate the results.</p></li>
</ul>
<h3>Creating the Project</h3>
<ol>
<li><p>To begin this tutorial, create a new workspace directory, and start the Vitis environment:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>mkdir ws_dsplib_tutorial_part_1
vitis
</pre></div>
</div>
</li>
<li><p>You will see the <em>Select a directory as workspace</em> window. Navigate to the <strong>ws_dsplib_tutorial_part_1</strong> directory, select it, and click <strong>Launch</strong>. The Vitis application window will appear.</p></li>
<li><p>We begin by creating a new application: Click <strong>Create Application Project</strong>. The <em>Create a New Application Project</em> window will appear, which explains the basic concepts of a Vitis project. Click <strong>Next</strong> when ready.</p></li>
<li><p>The <em>Platform</em> window will appear. Select <strong>xilinx_vck190_base_202120_1</strong> and click <strong>Next</strong>.</p></li>
<li><p>The <em>Application Project Details</em> window appears next. Give the application the name <strong>displib_tutorial_part_1</strong>. For the <em>Target processor</em>, select <strong>ai_engine</strong>,  and click <strong>Next</strong>.</p></li>
<li><p>The <em>Domain</em> window will appear. The default domain, <em>aiengine</em>, is the desired domain. Click <strong>Next</strong>.</p></li>
<li><p>The <em>Templates</em> window will appear next. Select <strong>Empty Application</strong> and click <strong>Finish</strong>.</p></li>
<li><p>Next, we will import the source and data files: In the project tree shown in the Explorer pane, right-click on the <strong>dsplib_tutorial_part_1</strong> project, and select <strong>Import Sources…</strong>.</p></li>
<li><p>Navigate to <strong>&lt;dsplib_tutorial_install&gt;/part_1</strong> and click <strong>Open</strong>. In the left pane, click on <strong>part_1</strong> to expand it, then click on the <strong>src</strong> and <strong>data</strong> folders. For the “into folder”, enter <strong>dsplib_tutorial_part_1</strong>, and click <strong>Finish</strong>.
<img alt="Importing Sources into a Vitis Project" src="../../../../_images/DSPLib_tutorial_part_1_Importing_Sources.png"/></p></li>
<li><p>With the files imported, you now need to specify which file is the top level. In the project tree shown in the <em>Explorer</em> pane, double-click on <strong>dsplib_tutorial_part_1.prj</strong>.</p></li>
<li><p>The <em>Application Project Settings</em> should appear in the main pane. Click on <strong>Click to select Top-Level File</strong>, and a <em>File Selection window</em> should appear. Expand the entries to select <strong>dsplib_tutorial_part_1/src/test.cpp</strong>, and click <strong>OK</strong>.</p></li>
<li><p>For this project to make use of the DSPLib functions, you need to tell the compiler where to find them.
Right-click on <strong>dsplib_tutorial_part_1</strong>, and click on <strong>C/C++ Build Settings</strong>.</p></li>
<li><p>Under the <em>Tools Settings</em> tab, <strong>AIE C Compiler</strong>/<strong>Input Spec</strong> should be highlighted (if it is not highlighted, select it). In the <strong>Include Paths</strong> pane, click the <strong>+</strong> sign, and add the directory for each of the following:</p></li>
</ol>
<ul class="simple">
<li><p>${env_var:DSPLIB_ROOT}/L1/src/aie</p></li>
<li><p>${env_var:DSPLIB_ROOT}/L1/include/aie</p></li>
<li><p>${env_var:DSPLIB_ROOT}/L2/include/aie</p></li>
</ul>
<p>The <em>Properties</em> Window should now look as follows:</p>
<p><img alt="Changing the Build Settings in a Vitis Project" src="../../../../_images/DSPLib_tutorial_part_1_Build_Settings.png"/></p>
<ol class="simple">
<li><p>Click <strong>Apply and Close</strong>, then respond <strong>Yes</strong> when asked if you want the index rebuilt.</p></li>
</ol>
<h3>Understanding the Source Files</h3>
<p>The <code class="docutils literal notranslate"><span class="pre">system_settings.h</span></code> files is a standard header file that defines the constants used in this project. It includes the header file “&lt;adf.h&gt;”. This is the Adaptive Data Flow (ADF) header file, which provides the classes used for specifying graphs. It also includes the FIR Filter kernel’s header file, <code class="docutils literal notranslate"><span class="pre">fir_sr_sym_graph.hpp</span></code>.</p>
<p>The design itself it implemented in <code class="docutils literal notranslate"><span class="pre">fir_graph.h</span></code>. A graph is used to define elements and the connections between them that make up the design. We will go over some of the key aspects of this file.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">using</span> <span class="n">namespace</span> <span class="n">adf</span>
<span class="n">namespace</span> <span class="n">dsplib</span> <span class="o">=</span> <span class="n">xf</span><span class="p">::</span><span class="n">dsp</span><span class="p">::</span><span class="n">aie</span><span class="p">;</span>
</pre></div>
</div>
<p>This simplifies accessing the ADF and DSPLib classes.</p>
<p>The FIR filter taps are declared as a vector, and initialized:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>	<span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int16</span><span class="o">&gt;</span> <span class="n">chan_taps</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int16</span><span class="o">&gt;</span><span class="p">{</span>
		 <span class="o">-</span><span class="mi">17</span><span class="p">,</span>      <span class="o">-</span><span class="mi">65</span><span class="p">,</span>      <span class="o">-</span><span class="mi">35</span><span class="p">,</span>       <span class="mi">34</span><span class="p">,</span>      <span class="o">-</span><span class="mi">13</span><span class="p">,</span>       <span class="o">-</span><span class="mi">6</span><span class="p">,</span>       <span class="mi">18</span><span class="p">,</span>      <span class="o">-</span><span class="mi">22</span><span class="p">,</span>
         <span class="o">....</span> <span class="p">};</span>
		 
</pre></div>
</div>
<p>The following line instantiates the DSPLib FIR filter kernel, named chan_FIR (channel filter):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>	<span class="n">dsplib</span><span class="p">::</span><span class="n">fir</span><span class="p">::</span><span class="n">sr_sym</span><span class="p">::</span><span class="n">fir_sr_sym_graph</span><span class="o">&lt;</span><span class="n">DATA_TYPE</span><span class="p">,</span> <span class="n">COEFF_TYPE</span><span class="p">,</span> <span class="n">FIR_LEN_CHAN</span><span class="p">,</span> <span class="n">SHIFT_CHAN</span><span class="p">,</span> <span class="n">ROUND_MODE_CHAN</span><span class="p">,</span> <span class="n">WINDOW_SIZE</span><span class="p">,</span> <span class="n">AIES_CHAN</span><span class="o">&gt;</span> <span class="n">chan_FIR</span><span class="p">;</span>
</pre></div>
</div>
<p>The filter’s template parameters and their meanings can be found in UG1295.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>	<span class="n">port</span><span class="o">&lt;</span><span class="nb">input</span><span class="o">&gt;</span> <span class="ow">in</span><span class="p">;</span>
	<span class="n">port</span><span class="o">&lt;</span><span class="n">output</span><span class="o">&gt;</span> <span class="n">out</span><span class="p">;</span>
</pre></div>
</div>
<p>Specifies the input and output ports for this graph, which are connected to in the higher level file <code class="docutils literal notranslate"><span class="pre">test.cpp</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>		<span class="n">connect</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="ow">in</span><span class="p">,</span> <span class="n">chan_FIR</span><span class="o">.</span><span class="ow">in</span><span class="p">);</span>
		<span class="n">connect</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">chan_FIR</span><span class="o">.</span><span class="n">out</span><span class="p">,</span> <span class="n">out</span><span class="p">);</span>
</pre></div>
</div>
<p>These statements connect our graph’s input and outputs to the FIR filter’s input and outputs, respectively.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>		<span class="n">location</span><span class="o">&lt;</span><span class="n">kernel</span><span class="o">&gt;</span><span class="p">(</span><span class="n">chan_FIR</span><span class="o">.</span><span class="n">m_firKernels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">=</span> <span class="n">tile</span><span class="p">(</span><span class="mi">18</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>This statement specifies a location attribute for the filter kernel. It specifies the X/Y location of the AI Engine tile within the AI Engine array in which to place the kernel. Location placements for kernels are optional, but shown here to illustrate how physical constraints can be incorporated into the source code. The results of this statement will be seen later when viewing the compilation results.</p>
<p>The third file, <code class="docutils literal notranslate"><span class="pre">test.cpp</span></code>, can be considered the testbench component. It is not intended for hardware implementation, but rather to drive the simulation.</p>
<p>The following statements instantiate programmable logic input/output (PLIO) elements, and binds them to a file. PLIO elements are points at which data can be moved onto and off of the AI Engine array.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">adf</span><span class="p">::</span><span class="n">PLIO</span> <span class="o">*</span><span class="n">pl128_in</span>  <span class="o">=</span> <span class="n">new</span> <span class="n">adf</span><span class="p">::</span><span class="n">PLIO</span><span class="p">(</span><span class="s2">"128 bits read in"</span><span class="p">,</span>  <span class="n">adf</span><span class="p">::</span><span class="n">plio_128_bits</span><span class="p">,</span><span class="s2">"data/input_128b.txt"</span><span class="p">,</span> <span class="mi">250</span><span class="p">);</span>
<span class="n">adf</span><span class="p">::</span><span class="n">PLIO</span> <span class="o">*</span><span class="n">pl128_out</span> <span class="o">=</span> <span class="n">new</span> <span class="n">adf</span><span class="p">::</span><span class="n">PLIO</span><span class="p">(</span><span class="s2">"128 bits read out"</span><span class="p">,</span> <span class="n">adf</span><span class="p">::</span><span class="n">plio_128_bits</span><span class="p">,</span><span class="s2">"data/output_128b_part_1.txt"</span><span class="p">,</span><span class="mi">250</span><span class="p">);</span>
</pre></div>
</div>
<p>The next pair of statements instantiate the platform, while also binding the previously described PLIO ports to it, and the following line instantiates the filter graph as defined in <code class="docutils literal notranslate"><span class="pre">fir_graph.h</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">simulation</span><span class="p">::</span><span class="n">platform</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">platform</span><span class="p">(</span><span class="n">pl128_in</span><span class="p">,</span> <span class="n">pl128_out</span><span class="p">);</span>
<span class="n">FirGraph</span> <span class="nb">filter</span><span class="p">;</span>
</pre></div>
</div>
<p>The next pair of lines connect the platform’s ports to the filter graph’s ports:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">connect</span><span class="o">&lt;&gt;</span> <span class="n">net0</span><span class="p">(</span><span class="n">platform</span><span class="o">.</span><span class="n">src</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">filter</span><span class="o">.</span><span class="ow">in</span><span class="p">);</span>
<span class="n">connect</span><span class="o">&lt;&gt;</span> <span class="n">net1</span><span class="p">(</span><span class="nb">filter</span><span class="o">.</span><span class="n">out</span><span class="p">,</span> <span class="n">platform</span><span class="o">.</span><span class="n">sink</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</pre></div>
</div>
<p>and finally, the main function is specified, which runs the simulation.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="n">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">filter</span><span class="o">.</span><span class="n">init</span><span class="p">()</span> <span class="p">;</span>
    <span class="nb">filter</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">NUM_ITER</span><span class="p">)</span> <span class="p">;</span>
    <span class="nb">filter</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<h3>Build AI Engine Emulation</h3>
<p>After the design files are complete, the next step is to choose a target by selecting a build configuration.</p>
<p>There are three build configurations:</p>
<ul class="simple">
<li><p><strong>Emulation-SW</strong> - Compiles to the x86 Simulator. Provides the quickest compiles and fastest validation cycles, but does not provide any implementation details.</p></li>
<li><p><strong>Emulation-AIE</strong> - Compiles to the AI Engine Simulator. A slower compile, but targets the AI Engine hardware, and provides implementation details.</p></li>
<li><p><strong>Hardware</strong> - Compiles to physical hardware. This is the most time-consuming build, and should be done once the design is verified and ready to be tested on hardware.</p></li>
</ul>
<p><img alt="Build Configuration Selection" src="../../../../_images/DSPLib_tutorial_part_1_Build_Emulation_AIE.png"/></p>
<p>In this tutorial, you will be targeting Emulation of the AI Engine. There are two ways to select the build configuration:</p>
<ol class="simple">
<li><p>From the <em>Explorer</em> pane, double-click on the application project file to open it, in this case, <strong>dsplib_tutorial_part_1.prj</strong>. After it  opens, you can select the build configuration on the upper right hand corner and select <strong>Emulation-AIE</strong>.</p></li>
<li><p>Click on the arrow symbol besides the hammer to select the active build configuration and select <strong>Emulation-AIE</strong>. This selects the AI Engine emulation and also starts the compilation process.</p></li>
</ol>
<p>After the build configuration is selected, you only need to click on the hammer symbol to (re)compile the project.</p>
<p>Building the project invokes the AI Engine compiler, which compiles the design, and maps it to the AI Engine tiles.</p>
<h3>Using Vitis Analyzer to look at the Compilation Results</h3>
<p>From the <em>Assistant</em> pane, expand the application (displib_tutorial_part_1), then expand the <strong>Emulation-AIE</strong> section, and double-click <strong>Compile Summary</strong>. Vitis Analyzer will now open.  After it opens, it will display the Summary page, which provides a brief summary of the project.</p>
<p><img alt="Vitis Analyzer Summary" src="../../../../_images/DSPLib_tutorial_part_1_Vitis_Analyzer_Summary.png"/></p>
<p>Selecting <strong>Graph</strong> on the navigation bar shows a diagram of the filter implementation. It illustrates the data connectivity points into and out of the graph (128-bit interfaces), and the symmetrical FIR filter kernel being implemented on a single tile with ping-pong buffers on either side of it.</p>
<p><img alt="Vitis Analyzer Graph" src="../../../../_images/DSPLib_tutorial_part_1_Vitis_Analyzer_Graph.png"/></p>
<p>Selecting <strong>Array</strong> on the navigation bar shows the physical implementation of the design on the AI Engine array. Here you can see the PLIO interfaces in pink, the AI Engine tile that implements the kernel in blue, and the ping pong buffers in purple. Note the kernel is located in tile (18,0), which was specified in <code class="docutils literal notranslate"><span class="pre">fir_filter.h</span></code>. Clicking on the components on the diagram will take you to the appropriate tab below which provides a description of the element. Conversely you can select the various element tabs (Kernels / PL / Buffers / Ports / Nets / Tiles) and click on a component to see where it is located on the array.</p>
<p><img alt="Vitis Analyzer Array" src="../../../../_images/DSPLib_tutorial_part_1_Vitis_Analyzer_Array.png"/></p>
<p>You can select the other entries on the navigation bar to see additional implementation details.</p>
<p>When you are done examining the design, click <strong>File -&gt; Exit</strong></p>
<h3>Running the Design through Simulation</h3>
<ol class="simple">
<li><p>In the <em>Explorer</em> pane, right-click on the application project <strong>dsplib_tutorial_part_1</strong>, and select <strong>Run As -&gt; Run Configurations…</strong>.</p></li>
<li><p>The <em>Create, manage and run configurations</em> window will appear. Click the <strong>Launch new configuration</strong> icon (the document with the plus sign).</p></li>
<li><p>Give the configuration a name, <strong>AI Engine Emulation Config</strong>.</p></li>
<li><p>Select the <strong>Main</strong> tab, check the <strong>Generate Trace</strong> checkbox, and select <strong>VCD</strong>. Click <strong>Run</strong>. The simulation will begin execution and the log appears on the <em>Console</em> pane below. Wait for the simulation to complete (the status bar on the lower right corner will disappear).</p></li>
</ol>
<h3>Using Vitis Analyzer to look at the Simulation Results</h3>
<p>From the <em>Assistant</em> pane, expand the application <strong>displib_tutorial_part_1</strong>, then expand the <strong>Emulation-AIE</strong> section, and double-click <strong>Run Summary</strong>. Vitis Analyzer will now open. After it opens, it will display the <em>Summary</em> page, which provides a brief summary of the simulation.</p>
<p>Selecting <strong>Trace</strong> on the navigation bar shows the simulation trace. Here you can see kernel activity, the DMA transfer activity, locks for the ping-pong buffers, etc.</p>
<p><img alt="Vitis Analyzer Trace" src="../../../../_images/DSPLib_tutorial_part_1_Vitis_Analyzer_Trace.png"/></p>
<h2>Part 2: Creating a Multi Kernel Graph</h2>
<p>Part 2 of this tutorial will:</p>
<ul class="simple">
<li><p>demonstrate how to connect together filters to create a filter chain.</p></li>
<li><p>show how to identify areas for optimization within the chain</p></li>
</ul>
<h3>Creating the Project</h3>
<p>For this part, you can create a new workspace and import the source files for part 2 as you did for part 1, or you can save some time and import the existing ZIP of the project provided.  For Part 2, we will demonstrate the latter option.</p>
<ol class="simple">
<li><p>Select <strong>File -&gt; Switch Workspace -&gt; Other…</strong>, click <strong>Browse…</strong>, then select the new folder icon, and give the new folder a name <strong>dsplib_tutorial_part_2</strong>.  Click <strong>Open</strong> and then <strong>Launch</strong>.</p></li>
<li><p>Select <strong>File -&gt; Import…</strong></p></li>
<li><p>Select <strong>Vitis project exported zip file</strong> and click <strong>Next</strong>.</p></li>
<li><p>Navigate to <strong>&lt;dsplib_tutorial_install&gt;/part_2</strong>, select <strong>dsplib_tutorial_part_2.ide.zip</strong>, click <strong>Open</strong>, and then click <strong>Finish</strong>. The reconstituted project should then appear in the Explorer pane.</p></li>
</ol>
<h3>Changes to the Filter Graph from Part 1</h3>
<p>For Part 2, we have cascaded a halfband filter after the FIR filter that was in the design in part 1.</p>
<p>In the <code class="docutils literal notranslate"><span class="pre">system_settings.h</span></code> file, constants for the halfband filter have been added, as well as the kernel’s header file, <code class="docutils literal notranslate"><span class="pre">fir_interpolate_hb_graph.hpp</span></code>.</p>
<p>In the file <code class="docutils literal notranslate"><span class="pre">fir_graph.h</span></code>, the notable changes are the following:</p>
<p>The constants for the second filter have been added:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int16</span><span class="o">&gt;</span> <span class="n">hb_taps</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int16</span><span class="o">&gt;</span><span class="p">{</span>
          <span class="mi">23</span><span class="p">,</span>      <span class="o">-</span><span class="mi">63</span><span class="p">,</span>      <span class="mi">143</span><span class="p">,</span>     <span class="o">-</span><span class="mi">281</span><span class="p">,</span>      <span class="mi">503</span><span class="p">,</span>     <span class="o">-</span><span class="mi">845</span><span class="p">,</span>     <span class="mi">1364</span><span class="p">,</span>    <span class="o">-</span><span class="mi">2173</span><span class="p">,</span>
        <span class="mi">3557</span><span class="p">,</span>    <span class="o">-</span><span class="mi">6568</span><span class="p">,</span>    <span class="mi">20729</span><span class="p">,</span>    <span class="mi">32767</span><span class="p">};</span>
</pre></div>
</div>
<p>The second (halfband) filter has been instantiated:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>	<span class="n">dsplib</span><span class="p">::</span><span class="n">fir</span><span class="p">::</span><span class="n">interpolate_hb</span><span class="p">::</span><span class="n">fir_interpolate_hb_graph</span><span class="o">&lt;</span><span class="n">DATA_TYPE</span><span class="p">,</span> <span class="n">COEFF_TYPE</span><span class="p">,</span> <span class="n">FIR_LEN_HB</span><span class="p">,</span> <span class="n">SHIFT_HB</span><span class="p">,</span> <span class="n">ROUND_MODE_HB</span><span class="p">,</span> <span class="n">WINDOW_SIZE</span><span class="o">&gt;</span> <span class="n">hb_FIR</span><span class="p">;</span>
</pre></div>
</div>
<p>Also, the output of the channel FIR filter is now cascaded into the halfband filter, whose output is now connected to the graph’s output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>		<span class="n">connect</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">chan_FIR</span><span class="o">.</span><span class="n">out</span><span class="p">,</span> <span class="n">hb_FIR</span><span class="o">.</span><span class="ow">in</span><span class="p">);</span>
		<span class="n">connect</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">hb_FIR</span><span class="o">.</span><span class="n">out</span><span class="p">,</span> <span class="n">out</span><span class="p">);</span>
</pre></div>
</div>
<p>The testbench file, <code class="docutils literal notranslate"><span class="pre">test.cpp</span></code>, is unchanged.</p>
<h3>Build AI Engine Emulation</h3>
<p>Building the AI Engine emulation for part 2 is identical to part 1, as described previously.</p>
<p>If the build was successful, you can continue straight on through to simulation.</p>
<h3>Running the Design through Simulation</h3>
<p>Running part 2 through simulation is identical to part 1, as described previously.</p>
<h3>Using Vitis Analyzer to look at the Compilation and Simulation Results</h3>
<p>From the Assistant pane, expand the application <strong>displib_tutorial_part_2</strong>, then expand the <strong>Emulation-AIE</strong> section, and double-click <strong>Run Summary</strong>. Vitis Analyzer will now open. After it opens, it will display the Summary page, which provides a brief summary of the simulation.</p>
<p>Selecting <strong>Graph</strong> on the navigation bar shows a diagram of the filter implementation. In this version of the graph, we can now see the two kernels, each implemented in the own AI Engine tile.</p>
<p><img alt="Vitis Analyzer Graph" src="../../../../_images/DSPLib_tutorial_part_3_Vitis_Analyzer_Graph.png"/></p>
<p>Selecting the <strong>Array</strong> option on the navigation bar shows the physical implementation of the design on the AI Engine array. You can see the two kernels are located in the tiles specified by the location constraints.</p>
<p><img alt="Vitis Analyzer Array" src="../../../../_images/DSPLib_tutorial_part_2_Vitis_Analyzer_Array.png"/></p>
<p>Selecting the <strong>Trace</strong> option on the navigation bar shows the tile (18,0) (the chan_FIR kernel) spending most of its time running kernel code, while tile (19,0) (hb_FIR) spends significant time being idle in _main. chan_FIR is the bottleneck in this datapath, which is not surprising because it has many more taps to compute.</p>
<p><img alt="Vitis Analyzer Trace" src="../../../../_images/DSPLib_tutorial_part_2_Vitis_Analyzer_Trace.png"/></p>
<p>In part 3, we are going to use filter parameters to attempt to increase the performance of the chan_FIR filter, to increase overall performance of the chain.</p>
<h2>Part 3: Optimizing Filter Performance</h2>
<p>Part 3 of this tutorial will:</p>
<ul class="simple">
<li><p>demonstrate how to use the CASC_LEN parameter to increase filter performance.</p></li>
</ul>
<h3>Creating the Project</h3>
<p>Creating part 3 of this project is identical to part 2, as described previously.</p>
<h3>Changes to the Filter Graph from Part 1</h3>
<p>For Part 3, we are going to increase the performance of the design by adjusting the TP_CASC_LEN parameter on the chan_FIR filter.</p>
<p>In <code class="docutils literal notranslate"><span class="pre">system_settings.h</span></code>, the following parameter has been changed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#define AIES_CHAN         5</span>
</pre></div>
</div>
<p>informing the library element to allocate 5 AI Engines to the FIR filter kernel.</p>
<p>In <code class="docutils literal notranslate"><span class="pre">fir_graph.h</span></code>, the only change here is using a for loop to lock the location constraints of the chan_FIR AI Engine tiles.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>        <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">AIES_CHAN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>  <span class="p">{</span>
                <span class="n">location</span><span class="o">&lt;</span><span class="n">kernel</span><span class="o">&gt;</span><span class="p">(</span><span class="n">chan_FIR</span><span class="o">.</span><span class="n">m_firKernels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">=</span> <span class="n">tile</span><span class="p">(</span><span class="mi">18</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">location</span><span class="o">&lt;</span><span class="n">kernel</span><span class="o">&gt;</span><span class="p">(</span><span class="n">hb_FIR</span><span class="o">.</span><span class="n">m_firKernels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">=</span> <span class="n">tile</span><span class="p">(</span><span class="mi">23</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>The testbench file, <code class="docutils literal notranslate"><span class="pre">test.cpp</span></code>, is unchanged.</p>
<h3>Build AI Engine Emulation</h3>
<p>Building the AI Engine emulation for part 3 is identical to part 1, as described previously.</p>
<p>If the build was successful, you can continue straight on through to simulation.</p>
<h3>Running the Design through Simulation</h3>
<p>Running part 3 through simulation is identical to part 1, as described previously.</p>
<h3>Using Vitis Analyzer to look at the Compilation and Simulation Results</h3>
<p>From the Assistant pane, expand the application <strong>displib_tutorial_part_3</strong>, then expand the <strong>Emulation-AIE</strong> section, and double-click <strong>Run Summary</strong>. Vitis Analyzer will now open. After it opens, it will display the Summary page, which provides a brief summary of the simulation.</p>
<p>Selecting <strong>Graph</strong> on the navigation bar shows a diagram of the filter implementation. It illustrates the data connectivity points into and out of the graph (128-bit interfaces), and the symmetrical FIR filter kernel being implemented on five tiles, followed by a single tile implementing the halfband filter.</p>
<p><img alt="Vitis Analyzer Graph" src="../../../../_images/DSPLib_tutorial_part_3_Vitis_Analyzer_Graph.png"/></p>
<p>Selecting the <strong>Array</strong> option on the navigation bar shows the physical implementation of the design on the AI Engine array; with the tile’s locations being determined by the location constraints.</p>
<p><img alt="Vitis Analyzer Array" src="../../../../_images/DSPLib_tutorial_part_3_Vitis_Analyzer_Array.png"/></p>
<p>Selecting the <strong>Trace</strong> option on the navigation bar now shows the channel filter tiles ((18,0) through (22,0)) almost fully occupied with processing the data; the computational load between the channel filter’s constituent engines now matching that of the halfband filter (23,0). The design now completes in 8 iterations in 24 microseconds, compared to 57.</p>
<p><img alt="Vitis Analyzer Trace" src="../../../../_images/DSPLib_tutorial_part_3_Vitis_Analyzer_Trace.png"/></p>
<h2>Conclusion</h2>
<p>This tutorial has demonstrated the following:</p>
<ul class="simple">
<li><p>How to create a Vitis AI Engine Project</p></li>
<li><p>How to create a graph based design description and described the basic element required</p></li>
<li><p>How to incorporate the FIR filter elements provided by the DSP Library</p></li>
<li><p>How to compile and simulate the design</p></li>
<li><p>How to view and interpret the results of an AI Engine based compilation and simulation</p></li>
<li><p>How to adjust FIR parameters to tune the design performance</p></li>
</ul>
<p>In doing so, it has hopefully provided a foundation upon which the user can begin to create their own designs in Vitis using the DSP Library.</p>
<h2>References</h2>
<p>The following documents provide supplemental material useful with this tutorial.</p>
<h3><a class="reference external" href="https://www.xilinx.com/support/documentation/sw_manuals/xilinx2021_2/ug1076-ai-engine-environment.pdf">UG1076 Versal ACAP AI Engine Programming Environment</a></h3>
<p>Contains chapters on how to develop AI Engine graphs, how to use the Ai Engine compiler, and AI Engine simulation, and performance analysis.</p>
<h3><a class="reference external" href="https://xilinx.github.io/Vitis_Libraries/dsp/2021.2/index.html">Vitis DSP Library (DSPLib) Documentation</a></h3>
<p>Contains information regarding the DSPLib example kernels used by this tutorial.</p>
<h3><a class="reference external" href="https://docs.xilinx.com/v/u/en-US/ug1416-vitis-documentation">Vitis Unified Software Development Platform 2021.2 Documentation</a></h3>
<p>Following links point to Vitis software platform related documents referred in this tutorial:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://docs.xilinx.com/r/en-US/ug1393-vitis-application-acceleration">Vitis Application Acceleration Development Flow Documentation</a></p></li>
<li><p><a class="reference external" href="https://github.com/Xilinx/Vitis-Tutorials">Vitis Application Acceleration Development Flow Tutorials</a></p></li>
</ul>
<h2>License</h2>
<p>Licensed under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License.</p>
<p>You may obtain a copy of the License at <a class="reference external" href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p align="center"><sup>XD022 | © Copyright 2021 Xilinx, Inc.</sup></p>
<footer>
<!-- Atalwar: Moved the footer code to layout.html to resolve conflict with the Xilinx template -->
</footer>
</div>