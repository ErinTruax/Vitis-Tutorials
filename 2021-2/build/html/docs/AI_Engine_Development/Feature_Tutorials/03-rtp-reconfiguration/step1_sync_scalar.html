
<table class="sphinxhide" width="100%">
<tr width="100%">
<td align="center"><img src="https://raw.githubusercontent.com/Xilinx/Image-Collateral/main/xilinx-logo.png" width="30%"/>
<a href="https://www.xilinx.com/products/design-tools/vitis.html">See Vitis™ Development Environment on xilinx.com</a>
<a href="https://www.xilinx.com/products/design-tools/vitis/vitis-ai.html">See Vitis-AI™ Development Environment on xilinx.com</a>
</td>
</tr>
</table>
<p>Kernel execution depends on the availability of windows of data on their inputs, and the space to write windows of data on their outputs. This example illustrates a complementary method, whereby a kernel will only get triggered to run after a write of data from another processor. This can be an ARM® processor or another AI Engine.</p>
<p>In this example, a write from an Arm processor causes a partial sine wave to be generated using the direct digital synthesis (DDS) kernel on the AI Engine. The Arm processor can control the frequency of the sine wave by writing different values to the <code class="docutils literal notranslate"><span class="pre">runtime</span></code> parameter. In the HW and HW cosim flow, the AI Engine output is streamed to the PL kernels, and the PS controls the running AI Engine and PL. The following figure shows this example.</p>
<p><img alt="design structure and flow" src="../../../../_images/figure1.PNG"/></p>
<p><strong>Note:</strong> The default working directory in this step is “step1”, unless specified explicitly otherwise.</p>
<h2>Review Graph Programming Code</h2>
<ol>
<li><p>Examine the header file <code class="docutils literal notranslate"><span class="pre">aie/dds.h</span></code>, of the sine kernel (DDS):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> ```
 void sine(const int32 phase_increment,output_window&lt;cint16&gt; * owin);
 ```
</pre></div>
</div>
<p>Now examine <code class="docutils literal notranslate"><span class="pre">aie/kernels/dds.cc</span></code>, and notice how <code class="docutils literal notranslate"><span class="pre">phase_increment</span></code> is used in the sine function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> ```
 phase_in += (phase_increment &lt;&lt; 6);
 auto [sin_,cos_] = aie::sincos(phase_in &lt;&lt; 14) ; // phase_in + (7i + j + 1) * phase_increment
 cint16 scvalues={cos_,sin_};
 ```
</pre></div>
</div>
</li>
<li><p>Examine <code class="docutils literal notranslate"><span class="pre">aie/graph.h</span></code> and <code class="docutils literal notranslate"><span class="pre">aie/graph.cpp</span></code>. These are provided as a starting point to specify the data flow graph of this example.</p>
<p>In <code class="docutils literal notranslate"><span class="pre">graph.h</span></code>, the kernel object <code class="docutils literal notranslate"><span class="pre">dds</span></code>, the graph input port <code class="docutils literal notranslate"><span class="pre">trigger</span></code>, and the graph output port <code class="docutils literal notranslate"><span class="pre">out</span></code> are declared in the <code class="docutils literal notranslate"><span class="pre">ddsgraph</span> <span class="pre">class</span></code>. The DDS kernel object is bound to the <code class="docutils literal notranslate"><span class="pre">sine</span></code> function declared in the included <code class="docutils literal notranslate"><span class="pre">dds.h</span></code> header. The DDS kernel output is connected to the graph output. It tells the compiler that the source for the function is in <code class="docutils literal notranslate"><span class="pre">kernels/dds.cc</span></code>. The kernel output is connected to <code class="docutils literal notranslate"><span class="pre">out.in[0]</span></code>, which will be directed to <code class="docutils literal notranslate"><span class="pre">data/output.txt</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> ```
 out = adf::output_plio::create("Dataout", adf::plio_32_bits, "data/output.txt");
 adf::connect&lt; adf::window&lt;512&gt; &gt;(dds.out[0], out.in[0]);
 ```
</pre></div>
</div>
<p>In <code class="docutils literal notranslate"><span class="pre">graph.cpp</span></code>, an instance of the <code class="docutils literal notranslate"><span class="pre">ddsgraph</span></code>, <code class="docutils literal notranslate"><span class="pre">gr</span></code>, is instantiated.</p>
<p>In the <code class="docutils literal notranslate"><span class="pre">main()</span></code> function, graph <code class="docutils literal notranslate"><span class="pre">init()</span></code>, <code class="docutils literal notranslate"><span class="pre">run()</span></code>, and <code class="docutils literal notranslate"><span class="pre">end()</span></code> are called to initialize, run, and wait to be ended.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> ```
 gr.init();
 gr.run(4);
 …
 gr.end();
 ```
</pre></div>
</div>
<p>The graph <code class="docutils literal notranslate"><span class="pre">run()</span></code> has been called with the parameter <code class="docutils literal notranslate"><span class="pre">4</span></code> to specify the iteration number of the graph. Otherwise, it will run forever.</p>
</li>
</ol>
<h2>Review RTP Update Code</h2>
<ol>
<li><p>Examine <code class="docutils literal notranslate"><span class="pre">aie/graph.h</span></code> again. The following line is to connect the trigger input port of the graph to the first input port of the dds kernel (i.e., the <code class="docutils literal notranslate"><span class="pre">phase_increment</span></code> parameter of the <code class="docutils literal notranslate"><span class="pre">sine</span></code> function).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> ```
 adf::connect&lt;adf::parameter&gt;(trigger, dds.in[0]);
 ```
</pre></div>
</div>
<p>The syntax of this connection is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```
 adf::connect&lt;adf::parameter&gt;(input_port&amp;, output_port&amp;);
 ```
</pre></div>
</div>
<p><strong>Note:</strong> You need to use the template class argument <code class="docutils literal notranslate"><span class="pre">adf::parameter</span></code> to specialize the connection type to the parameter type (because you are now connecting parameters and not windows of data). The parameter does not need to be sized in the same way as a window, because the compiler can always determine its size.</p>
</li>
<li><p>Examine <code class="docutils literal notranslate"><span class="pre">aie/graph.cpp</span></code>. You can see the lines of code to update the RTP. Note that the number of updates matches the number of iterations specified in <code class="docutils literal notranslate"><span class="pre">gr.run(4)</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```
gr.update(gr.trigger,10);

gr.update(gr.trigger,10);

gr.update(gr.trigger,100);

gr.update(gr.trigger,100);
```
</pre></div>
</div>
<p>The graph update calls update:</p>
<ul class="simple">
<li><p>The trigger input with a value of 10 in the ping buffer</p></li>
<li><p>The trigger input with a value of 10  in the pong buffer</p></li>
<li><p>The trigger input with a value of 100 in the ping buffer</p></li>
<li><p>The trigger input with a value of 100 in the pong buffer</p></li>
</ul>
<p>The syntax of the graph update function is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```
void adf::graph::update(input_port &amp;portName, int value);
```
</pre></div>
</div>
<p>Because the <code class="docutils literal notranslate"><span class="pre">runtime</span></code> parameter in this example is synchronous, the graph execution on the AI Engine will start after the first update call for one iteration, then wait for the next trigger by the next update call. Four consecutive update calls will run the graph for four iterations, where the first two iterations use 10 as the value for the <code class="docutils literal notranslate"><span class="pre">phase_increment</span></code> parameter and the last two iterations use 100.</p>
</li>
</ol>
<h2>Run AI Engine Compiler and AI Engine Simulator</h2>
<ol>
<li><p>Run the AI Engine compiler and the AI Engine simulator to verify the functional correctness of the design. Note that <code class="docutils literal notranslate"><span class="pre">graph.cpp</span></code> is only used for the AI Engine simulator, which is a SystemC simulation.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">make</span></code> command to run the AI Engine compiler to generate the AI Engine design graph (<code class="docutils literal notranslate"><span class="pre">libadf.a</span></code>) is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> ```
 make aie
 ```
</pre></div>
</div>
<p>The corresponding command for aiecompiler is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```
aiecompiler -platform=$PLATFORM_REPO_PATHS/xilinx_vck190_es1_base_202120_1/xilinx_vck190_es1_base_202120_1.xpfm -include="./aie" -include="./data" -include="./aie/kernels" -include="./" -workdir=./Work aie/graph.cpp
```
</pre></div>
</div>
<p>Switches for the AI Engine are as follows:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-platform</span></code>: specifies the path to the target platform</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-include</span></code>: specifies the path to find header and source files</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-workdir</span></code>: specifies the output directory. By default, the compiler generates all its output into a subdirectory called <code class="docutils literal notranslate"><span class="pre">Work</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">aie/graph.cpp</span></code>: specifies the graph source file</p></li>
</ul>
<p>For more information about AI Engine programming and tools, refer to the <em>Versal ACAP AI Engine Programming Environment User Guide</em> (UG1076).</p>
</li>
<li><p>After the graph has been compiled, run <code class="docutils literal notranslate"><span class="pre">aiesimulator</span></code> using the following make command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```
make aiesim
```
</pre></div>
</div>
<p>The corresponding AI Engine simulator command is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```
 aiesimulator --pkg-dir=./Work
 ```
</pre></div>
</div>
<p>After simulation completes, you should see the <code class="docutils literal notranslate"><span class="pre">output.txt</span></code> file in <code class="docutils literal notranslate"><span class="pre">aiesimulator_output/data</span></code>. The output file contains output data and timestamps. You can compare the generated <code class="docutils literal notranslate"><span class="pre">output.txt</span></code> file with the golden reference file (<code class="docutils literal notranslate"><span class="pre">data/golden.txt</span></code>) using the following commands in command line:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```
 grep -v T aiesimulator_output/data/output.txt &gt; aiesimulator_output/data/output_data.txt
diff -w aiesimulator_output/data/output_data.txt ./data/golden.txt
 ```
</pre></div>
</div>
<p>The timestamps in <code class="docutils literal notranslate"><span class="pre">output.txt</span></code> are removed in the new output file <code class="docutils literal notranslate"><span class="pre">output_data.txt</span></code>. The new output file should match the data in <code class="docutils literal notranslate"><span class="pre">golden.txt</span></code>. If the files match it is normal to see no output from the diff command.</p>
<p>If you are using MATLAB or Octave, you can use the following script to visualize the data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```
data=load('./aiesimulator_output/data/output_data.txt', '-ascii');
plot(data(:,1))
```
</pre></div>
</div>
<p>This plots the first column (real part) of the output complex data.</p>
</li>
</ol>
<p><img alt="sine waveform - real" src="../../../../_images/figure2.PNG"/></p>
<p>In <code class="docutils literal notranslate"><span class="pre">aie/kernels/dds.cc</span></code>, the sine kernel function uses the sincos intrinsic with the phase parameter to generate 32-bit integer concatenating Sine (bits [31:16]) and Cosine (bits [15:0]) in signed Q.15 fixed-point format. The 32-bit integer output samples are cast and stored in a <code class="docutils literal notranslate"><span class="pre">cint16</span></code> window. As a result, the first column (real part) represents a cosine waveform. In the four iterations, the first two iterations use a value of 10 as the <code class="docutils literal notranslate"><span class="pre">phase_increment</span></code> parameter and the last two iterations use 100, so you see the cosine waveform frequency increases in the middle of the plot.</p>
<ol>
<li><p>Use the following line to plot the second column (imaginary part) of the output complex data.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```
plot(data(:,2))
```
</pre></div>
</div>
<p>The following plot shows the sine waveform generated by the <code class="docutils literal notranslate"><span class="pre">sine</span></code> kernel function with the frequency changed in the middle of the simulation iterations.</p>
</li>
</ol>
<p><img alt="sine waveform - imaginary" src="../../../../_images/figure3.PNG"/></p>
<h3>Build for Hardware Emulation and Hardware Flow</h3>
<p>In the previous step, you generated the AI Engine design graph (<code class="docutils literal notranslate"><span class="pre">libadf.a</span></code>) using the AI Engine compiler. Note that the graph has instantiated a PLIO (<code class="docutils literal notranslate"><span class="pre">adf::output_plio</span></code> in <code class="docutils literal notranslate"><span class="pre">aie/graph.h</span></code>), which will be connected to the PL side.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```
 out = adf::output_plio::create("Dataout", adf::plio_32_bits, "data/output.txt");
 ```
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">plio_32_bits</span></code> indicates the interface to the PL side is 32 bits wide. In the PL side, an HLS kernel <code class="docutils literal notranslate"><span class="pre">s2mm</span></code> will be instantiated. It will receive stream data from the AI Engine graph, and output data to global memory, which will be read by the host code in the PS.</p>
<p><strong>Note</strong>: In this section, the make commands apply to <code class="docutils literal notranslate"><span class="pre">hw_emu</span></code> mode by default. Taking the <code class="docutils literal notranslate"><span class="pre">hw_emu</span></code> mode as an example, to target <code class="docutils literal notranslate"><span class="pre">hw</span></code> mode, add <code class="docutils literal notranslate"><span class="pre">TARGET=hw</span></code> to the make commands. For detailed commands, change the <code class="docutils literal notranslate"><span class="pre">-t</span> <span class="pre">hw_emu</span></code> option to <code class="docutils literal notranslate"><span class="pre">-t</span> <span class="pre">hw</span></code>.</p>
<p>To compile the HLS PL kernel, run the following make command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```
make kernels
```
</pre></div>
</div>
<p>The corresponding v++ compiler command is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```
v++ -c --platform xilinx_vck190_es1_base_202120_1 -k s2mm s2mm.cpp -o s2mm.xo --verbose --save-temps
```
</pre></div>
</div>
<p>Switches for the v++ compiler are as follows:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-c</span></code>: compiles the kernel source into Xilinx object (<code class="docutils literal notranslate"><span class="pre">.xo</span></code>) files.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">--platform</span></code>: specifies the name of a supported platform as specified by the <em><code class="docutils literal notranslate"><span class="pre">PLATFORM_REPO_PATHS</span></code></em> environment variable, or the full path to the platform <code class="docutils literal notranslate"><span class="pre">.xpfm</span></code> file.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-k</span></code>: specifies the kernel name.</p></li>
</ul>
<p>The next step is to link the AI Engine graph and PL kernels to generate the hardware platform. The make command for this is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">xclbin</span>
</pre></div>
</div>
<p>This make takes 10 minutes or more to complete. The corresponding v++ linker command is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```
v++ -g -l --platform xilinx_vck190_es1_base_202120_1 pl_kernels/s2mm.xo libadf.a -t hw_emu --save-temps --verbose --config system.cfg -o vck190_aie_base_graph_hw_emu.xclbin
```
</pre></div>
</div>
<p>Switches for the v++ linker are as follows:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-l</span></code>: links the PL kernels, AI Engine graph and platform into an FPGA binary file (<code class="docutils literal notranslate"><span class="pre">xclbin</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-t</span></code>: specifies the link target, <code class="docutils literal notranslate"><span class="pre">hw</span></code> for hardware run, <code class="docutils literal notranslate"><span class="pre">hw_emu</span></code> for HW emulation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">--config</span></code>: specifies the configuration file. The configuration file (<code class="docutils literal notranslate"><span class="pre">system.cfg</span></code>), specifies stream connections between the Graph and PL kernels, and other optional selections.</p></li>
</ul>
<p>After generating the hardware platform, compile the host code (<code class="docutils literal notranslate"><span class="pre">sw/host.cpp</span></code>) using the following make command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```
make host
```
</pre></div>
</div>
<p>The detailed commands for compiling the host code are as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```
${CXX} -std=c++14 -I$XILINX_HLS/include/ -I$PLATFORM_REPO_PATHS/sw/versal/xilinx-versal-common-v2021.2/sysroots/aarch64-xilinx-linux//usr/include/xrt/ -O0 -g -Wall -c -fmessage-length=0 --sysroot=$PLATFORM_REPO_PATHS/sw/versal/xilinx-versal-common-v2021.2/sysroots/aarch64-xilinx-linux/ -I$XILINX_VITIS/aietools/include -I../ -I../aie -o aie_control_xrt.o aie_control_xrt.cpp
${CXX} -std=c++14 -I$XILINX_HLS/include/ -I$PLATFORM_REPO_PATHS/sw/versal/xilinx-versal-common-v2021.2/sysroots/aarch64-xilinx-linux//usr/include/xrt/ -O0 -g -Wall -c -fmessage-length=0 --sysroot=$PLATFORM_REPO_PATHS/sw/versal/xilinx-versal-common-v2021.2/sysroots/aarch64-xilinx-linux/ -I$XILINX_VITIS/aietools/include -I../ -I../aie -o host.o host.cpp
${CXX} -o ../host.exe aie_control_xrt.o host.o -ladf_api_xrt -lgcc -lc -lxrt_coreutil -lxilinxopencl -lpthread -lrt -ldl -lcrypt -lstdc++ -L$PLATFORM_REPO_PATHS/sw/versal/xilinx-versal-common-v2021.2/sysroots/aarch64-xilinx-linux//usr/lib/ --sysroot=$PLATFORM_REPO_PATHS/sw/versal/xilinx-versal-common-v2021.2/sysroots/aarch64-xilinx-linux/ -L$XILINX_VITIS/aietools/lib/aarch64.o
```
</pre></div>
</div>
<p>Here, the cross compiler pointed by <code class="docutils literal notranslate"><span class="pre">CXX</span></code> is used to compile the linux host code. <code class="docutils literal notranslate"><span class="pre">aie_control_xrt.cpp</span></code> is copied from the directory <code class="docutils literal notranslate"><span class="pre">Work/ps/c_rts</span></code>.</p>
<p>The host code for HW emulation and HW (<code class="docutils literal notranslate"><span class="pre">sw/host.cpp</span></code>) includes OpenCL APIs to control the executions of PL kernels, and adf APIs <code class="docutils literal notranslate"><span class="pre">(*init(),update(),run(),wait()*)</span></code>. The execution model of the PL kernel is composed of the following steps:</p>
<ol>
<li><p>Get the OpenCL platform and device:</p>
<p>a. Prepare OpenCL context and command queue.</p>
<p>b. Program <code class="docutils literal notranslate"><span class="pre">xclbin</span></code>.</p>
<p>c. Get kernel objects from the program.</p>
</li>
<li><p>Prepare the device buffers for kernels. Transfer data from the host memory to the global memory in the device.</p></li>
<li><p>The host program sets up the kernel with its input parameters and triggers the execution of the kernel on the FPGA.</p></li>
<li><p>Wait for kernel completion.</p></li>
<li><p>Transfer data from the device global memory to host memory.</p></li>
<li><p>Host code performs post-processing on the host memory.</p></li>
</ol>
<p>Following is a code snippet from <code class="docutils literal notranslate"><span class="pre">sw/host.cpp</span></code> to illustrate these concepts:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```
#include "adf/adf_api/XRTConfig.h"
#include "experimental/xrt_kernel.h"
...
//1. Get OpenCL platform and device, prepare OpenCL context and command queue. Program xclbin, and get kernel objects from the program. adf::registerXRT() is needed for ADF API.
cl::Device device;
std::vector&lt;cl::Platform&gt; platforms;
cl::Platform::get(&amp;platforms);
...
cl::Context context(device);
cl::CommandQueue q(context, device, CL_QUEUE_PROFILING_ENABLE | CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE);
...
cl::Program::Binaries bins;
cl::Program program(context, devices, bins);
cl::Kernel krnl_s2mm(program,"s2mm"); //get kernel object
...
// Create XRT device handle for ADF API
void *dh;
device.getInfo(CL_DEVICE_HANDLE, &amp;dh);
auto dhdl = xrtDeviceOpenFromXcl(dh);
auto top = reinterpret_cast&lt;const axlf*&gt;(buf);
adf::registerXRT(dhdl, uuid);

//2. Prepare device buffers for kernels. Transfer data from host memory to global memory in device. 
std::complex&lt;short&gt; *host_out; //host buffer
cl::Buffer buffer_out(context, CL_MEM_WRITE_ONLY, output_size_in_bytes);
host_out=(std::complex&lt;short&gt;*)q.enqueueMapBuffer(buffer_out,true,CL_MAP_READ,0,sizeof(int)*OUTPUT_SIZE,nullptr,nullptr,nullptr);

//3. The host program sets up the kernel with its input parameters
krnl_s2mm.setArg(0,buffer_out);
krnl_s2mm.setArg(2,OUTPUT_SIZE);

//Launch the Kernel
q.enqueueTask(krnl_s2mm);

// ADF API: Initialize, run and update graph parameters (RTP)
gr.run(4);
gr.update(gr.trigger,10);
gr.update(gr.trigger,10);
gr.update(gr.trigger,100);
gr.update(gr.trigger,100);
gr.wait();

//4. Wait for kernel completion. 
q.finish();//Wait for s2mm to complete    

//5. Transfer data from global memory in device to host memory.
q.enqueueMigrateMemObjects({buffer_out},CL_MIGRATE_MEM_OBJECT_HOST);	
q.finish();//Wait for memory transfer to complete

//6. post-processing on host memory - "host_out"
```
</pre></div>
</div>
<p>Head files <code class="docutils literal notranslate"><span class="pre">adf/adf_api/XRTConfig.h</span></code> and <code class="docutils literal notranslate"><span class="pre">experimental/xrt_kernel.h</span></code> are needed by the <code class="docutils literal notranslate"><span class="pre">adf</span></code> API and XRT API.</p>
<p><strong>Note</strong>: In this example, graph execution needs to start before <code class="docutils literal notranslate"><span class="pre">finish()</span></code> for the command queue. If <code class="docutils literal notranslate"><span class="pre">finish()</span></code> is invoked first, which is a blocking call, the graph will never start and provide output to s2mm, and hence the application will hang on the blocked point.</p>
<p>The next step is to use v++ with <code class="docutils literal notranslate"><span class="pre">-p</span></code> to generate the package file. The make command is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">package</span>
</pre></div>
</div>
<p>The corresponding v++ command is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```
v++ -p -t hw_emu -f $PLATFORM_REPO_PATHS/xilinx_vck190_es1_base_202120_1/xilinx_vck190_es1_base_202120_1.xpfm \
--package.rootfs $PLATFORM_REPO_PATHS/sw/versal/xilinx-versal-common-v2021.2/rootfs.ext4  \
--package.kernel_image $PLATFORM_REPO_PATHS/sw/versal/xilinx-versal-common-v2021.2/Image  \
--package.boot_mode=sd \
--package.image_format=ext4 \
--package.defer_aie_run \
--package.sd_dir data \
--package.sd_file host.exe vck190_aie_base_graph_hw_emu.xclbin libadf.a
```
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">--package.defer_aie_run</span></code> specifies that the Versal AI Engine cores will be enabled by the PS. When not specified, the tool will generate CDO commands to enable the AI Engine cores during PDI load instead.</p>
<p><code class="docutils literal notranslate"><span class="pre">--package.sd_dir</span> <span class="pre">&lt;arg&gt;</span></code> specifies a directory path to package into the *<code class="docutils literal notranslate"><span class="pre">sd_card*</span> <span class="pre">directory/image</span></code>, which is helpful for including some golden data into the package.</p>
<p>“<code class="docutils literal notranslate"><span class="pre">--package.sd_file</span> <span class="pre">&lt;arg&gt;</span></code>” is used to specify files to package into the *<code class="docutils literal notranslate"><span class="pre">sd_card*</span> <span class="pre">directory/image</span></code>.</p>
<p>For more details about <code class="docutils literal notranslate"><span class="pre">v++</span> <span class="pre">-p</span> <span class="pre">(--package)</span></code> options, refer to <em>Application Acceleration Development</em> (UG1393).</p>
<h2>Deploy for Hardware Emulation and Hardware Flow</h2>
<p>The final step is to run HW emulation using the following make command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```
make run_hw_emu
```
</pre></div>
</div>
<p>The corresponding script is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```
./launch_hw_emu.sh
```
</pre></div>
</div>
<p><strong>Hint:</strong> Option <code class="docutils literal notranslate"><span class="pre">-add-env</span> <span class="pre">VITIS_LAUNCH_WAVEFORM_BATCH=1</span></code> can be added to <code class="docutils literal notranslate"><span class="pre">launch_hw_emu.sh</span></code> to record the waveform of the platform into waveform file (<code class="docutils literal notranslate"><span class="pre">*.wdb</span></code>).</p>
<p><strong>Hint:</strong> Hitting a key accidentally will prevent the system booting automatically. If this happens, type <code class="docutils literal notranslate"><span class="pre">boot</span></code> in the <code class="docutils literal notranslate"><span class="pre">Versal&gt;</span></code> prompt to resume the system booting.</p>
<p>After Linux has booted, run following commands in Linux prompt (this is only for HW cosim):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```
mount /dev/mmcblk0p1 /mnt
cd /mnt
export XILINX_XRT=/usr
export XCL_EMULATION_MODE=hw_emu
./host.exe a.xclbin
```
</pre></div>
</div>
<p>To exit QEMU press Ctrl+A, x</p>
<p>Alternatively, to run in hardware, after booting Linux, run following commands in the Linux prompt:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```
export XILINX_XRT=/usr
cd /mnt/sd-mmcblk0p1
./host.exe a.xclbin
```
</pre></div>
</div>
<p>The host code is self-checking. It will check the output data against the golden data. If the output data matches the golden data, after the run is completed, it will print:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>```
TEST PASSED
```
</pre></div>
</div>
<h2>Conclusion</h2>
<p>In this step, you learned about the following core concepts:</p>
<ul class="simple">
<li><p>Synchronous update of scalar RTP</p></li>
<li><p>Flows to perform AI Engine simulation</p></li>
<li><p>HW emulation and HW run</p></li>
</ul>
<p>Next, review <a class="reference internal" href="step2_async_scalar.html"><span class="doc">Asynchronous Update of Scalar RTP</span></a>.</p>
<p>==========</p>
<p>GitHub issues will be used for tracking requests and bugs. For questions go to <a class="reference external" href="http://forums.xilinx.com/">forums.xilinx.com</a>.</p>
<p>Licensed under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License.</p>
<p>You may obtain a copy of the License at <a class="reference external" href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p align="center"><sup>XD001 | © Copyright 2020-2021 Xilinx, Inc.</sup></p><p>==========</p>
<footer>
<!-- Atalwar: Moved the footer code to layout.html to resolve conflict with the Xilinx template -->
</footer>
