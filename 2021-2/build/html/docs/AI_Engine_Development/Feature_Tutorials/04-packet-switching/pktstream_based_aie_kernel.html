
<table class="sphinxhide" width="100%">
<tr width="100%">
<td align="center"><img src="https://raw.githubusercontent.com/Xilinx/Image-Collateral/main/xilinx-logo.png" width="30%"/>
<a href="https://www.xilinx.com/products/design-tools/vitis.html">See Vitis™ Development Environment on xilinx.com</a>
<a href="https://www.xilinx.com/products/design-tools/vitis/vitis-ai.html">See Vitis-AI™ Development Environment on xilinx.com</a>
</td>
</tr>
</table>
<p>Packet Stream-based AI Engine kernels allow fine-grain control over how packets are generated and consumed in the kernels. This section explains how to code AI Engine kernels with packet stream interfaces (<code class="docutils literal notranslate"><span class="pre">input_pktstream</span></code> and <code class="docutils literal notranslate"><span class="pre">output_pktstream</span></code>). The connection in the graph is also described.</p>
<p>The PL side and PS side of this example is the same as <a class="reference internal" href="window_based_aie_kernel.html"><span class="doc">Window Based AI Engine Kernels</span></a>. Refer to:</p>
<ul class="simple">
<li><p><a class="reference external" href="./window_based_aie_kernel.md/#Packet-Format">Packet Format</a></p></li>
<li><p><a class="reference external" href="./window_based_aie_kernel.md/#Example-PL-Kernels-for-Packet-Switching">Example PL Kernels for Packet Switching</a></p></li>
<li><p><a class="reference external" href="./window_based_aie_kernel.md/#Example-PS-code-for-Packet-Switching">Example PS code for Packet Switching</a></p></li>
</ul>
<h2>Packet Stream Interfaces and Operations</h2>
<p>Two stream types are provided to denote streaming data, consisting of packetized interleaving of several different streams. These types are listed in the following table.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Input Stream Types</th>
<th>Output Stream Types</th>
</tr>
</thead>
<tbody>
<tr>
<td>input_pktstream</td>
<td>output_pktstream</td>
</tr>
</tbody>
</table><p>A data packet consists of a one word (32-bit) packet header, followed by some number of data words where the last data word has the TLAST field denoting the end-of-packet. The following operations are used to read and advance input packet streams and write and advance output packet streams.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">int32</span> <span class="n">readincr</span><span class="p">(</span><span class="n">input_pktstream</span> <span class="o">*</span><span class="n">w</span><span class="p">);</span>
<span class="n">int32</span> <span class="n">readincr</span><span class="p">(</span><span class="n">input_pktstream</span> <span class="o">*</span><span class="n">w</span><span class="p">,</span> <span class="nb">bool</span> <span class="o">&amp;</span><span class="n">tlast</span><span class="p">);</span>
<span class="n">void</span> <span class="n">writeincr</span><span class="p">(</span><span class="n">output_pktstream</span> <span class="o">*</span><span class="n">w</span><span class="p">,</span> <span class="n">int32</span> <span class="n">value</span><span class="p">);</span>
<span class="n">void</span> <span class="n">writeincr</span><span class="p">(</span><span class="n">output_pktstream</span> <span class="o">*</span><span class="n">w</span><span class="p">,</span> <span class="n">int32</span> <span class="n">value</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">tlast</span><span class="p">);</span>
</pre></div>
</div>
<p>The API with the <code class="docutils literal notranslate"><span class="pre">TLAST</span></code> argument reads or writes the end-of-packet condition if the packet size is not fixed.</p>
<p>The AI Engine tools provide the built-in function <code class="docutils literal notranslate"><span class="pre">writeHeader</span></code> to generate a packet header for packets originating from the AI Engine kernel and writes them to the output.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">writeHeader</span><span class="p">(</span><span class="n">output_pktstream</span> <span class="o">*</span><span class="nb">str</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">pcktType</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">ID</span><span class="p">);</span>
<span class="n">void</span> <span class="n">writeHeader</span><span class="p">(</span><span class="n">output_pktstream</span> <span class="o">*</span><span class="nb">str</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">pcktType</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">ID</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">tlast</span><span class="p">);</span>
</pre></div>
</div>
<p>The AI Engine tools also provide the built-in function <code class="docutils literal notranslate"><span class="pre">getPacketid</span></code> to get the packet ID for the packet stream interface. The index for <code class="docutils literal notranslate"><span class="pre">getPacketid</span></code> only applies if the packet stream feeds into a <code class="docutils literal notranslate"><span class="pre">pktsplit</span></code>. In this example, each AI Engine kernel output sees only one logical stream (0 for index).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">uint32_t</span> <span class="n">getPacketid</span><span class="p">(</span><span class="n">input_pktstream</span> <span class="o">*</span> <span class="ow">in</span><span class="p">,</span> <span class="nb">int</span> <span class="n">index</span><span class="p">);</span>
<span class="n">uint32_t</span> <span class="n">getPacketid</span><span class="p">(</span><span class="n">output_pktstream</span> <span class="o">*</span> <span class="n">out</span><span class="p">,</span> <span class="nb">int</span> <span class="n">index</span><span class="p">);</span>   
</pre></div>
</div>
<p>Change working directory to <code class="docutils literal notranslate"><span class="pre">pktstream_aie</span></code>. Review the AI Engine kernels (<code class="docutils literal notranslate"><span class="pre">aie/aie_core1.cpp</span></code>, … , <code class="docutils literal notranslate"><span class="pre">aie/aie_core4.cpp</span></code>). The code for <code class="docutils literal notranslate"><span class="pre">aie_core1</span></code> (<code class="docutils literal notranslate"><span class="pre">aie/aie_core1.cpp</span></code>) is as follows.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">aie_core1</span><span class="p">(</span><span class="n">input_pktstream</span> <span class="o">*</span><span class="ow">in</span><span class="p">,</span><span class="n">output_pktstream</span> <span class="o">*</span><span class="n">out</span><span class="p">){</span>
	<span class="n">readincr</span><span class="p">(</span><span class="ow">in</span><span class="p">);</span><span class="o">//</span><span class="n">read</span> <span class="n">header</span> <span class="ow">and</span> <span class="n">discard</span>
	<span class="n">uint32</span> <span class="n">ID</span><span class="o">=</span><span class="n">getPacketid</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span><span class="o">//</span><span class="k">for</span> <span class="n">output</span> <span class="n">pktstream</span>
	<span class="n">writeHeader</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="n">pktType</span><span class="p">,</span><span class="n">ID</span><span class="p">);</span> <span class="o">//</span><span class="n">Generate</span> <span class="n">header</span> <span class="k">for</span> <span class="n">output</span>

	<span class="nb">bool</span> <span class="n">tlast</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
		<span class="n">int32</span> <span class="n">tmp</span><span class="o">=</span><span class="n">readincr</span><span class="p">(</span><span class="ow">in</span><span class="p">,</span><span class="n">tlast</span><span class="p">);</span>
		<span class="n">tmp</span><span class="o">+=</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">writeincr</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="n">tmp</span><span class="p">,</span><span class="n">i</span><span class="o">==</span><span class="mi">7</span><span class="p">);</span><span class="o">//</span><span class="n">TLAST</span><span class="o">=</span><span class="mi">1</span> <span class="k">for</span> <span class="n">last</span> <span class="n">word</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It can be seen that the input packet header is discarded. The output header is generated by <code class="docutils literal notranslate"><span class="pre">writeHeader</span></code>, and the packet ID for the header is obtained by <code class="docutils literal notranslate"><span class="pre">getPacketid</span></code>. <code class="docutils literal notranslate"><span class="pre">TLAST</span></code> equals 1 for the last word in the packet.</p>
<h2>Construct Graph for Packet Stream Kernels</h2>
<p>Review how the graph is constructed in <code class="docutils literal notranslate"><span class="pre">aie/graph.h</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">using</span> <span class="n">namespace</span> <span class="n">adf</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">mygraph</span><span class="p">:</span> <span class="n">public</span> <span class="n">adf</span><span class="p">::</span><span class="n">graph</span> <span class="p">{</span>
<span class="n">private</span><span class="p">:</span>
  <span class="n">adf</span><span class="p">::</span> <span class="n">kernel</span> <span class="n">core</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

  <span class="n">adf</span><span class="p">::</span> <span class="n">pktsplit</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span> <span class="n">sp</span><span class="p">;</span>
  <span class="n">adf</span><span class="p">::</span> <span class="n">pktmerge</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span> <span class="n">mg</span><span class="p">;</span>
<span class="n">public</span><span class="p">:</span>
  <span class="n">adf</span><span class="p">::</span><span class="n">input_plio</span>  <span class="ow">in</span><span class="p">;</span>
  <span class="n">adf</span><span class="p">::</span><span class="n">output_plio</span>  <span class="n">out</span><span class="p">;</span>
  <span class="n">mygraph</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">core</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">adf</span><span class="p">::</span><span class="n">kernel</span><span class="p">::</span><span class="n">create</span><span class="p">(</span><span class="n">aie_core1</span><span class="p">);</span>
    <span class="n">core</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">adf</span><span class="p">::</span><span class="n">kernel</span><span class="p">::</span><span class="n">create</span><span class="p">(</span><span class="n">aie_core2</span><span class="p">);</span>
    <span class="n">core</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">adf</span><span class="p">::</span><span class="n">kernel</span><span class="p">::</span><span class="n">create</span><span class="p">(</span><span class="n">aie_core3</span><span class="p">);</span>
    <span class="n">core</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">adf</span><span class="p">::</span><span class="n">kernel</span><span class="p">::</span><span class="n">create</span><span class="p">(</span><span class="n">aie_core4</span><span class="p">);</span>
    <span class="n">adf</span><span class="p">::</span><span class="n">source</span><span class="p">(</span><span class="n">core</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">=</span> <span class="s2">"aie_core1.cpp"</span><span class="p">;</span>
    <span class="n">adf</span><span class="p">::</span><span class="n">source</span><span class="p">(</span><span class="n">core</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">=</span> <span class="s2">"aie_core2.cpp"</span><span class="p">;</span>
    <span class="n">adf</span><span class="p">::</span><span class="n">source</span><span class="p">(</span><span class="n">core</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">=</span> <span class="s2">"aie_core3.cpp"</span><span class="p">;</span>
    <span class="n">adf</span><span class="p">::</span><span class="n">source</span><span class="p">(</span><span class="n">core</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">=</span> <span class="s2">"aie_core4.cpp"</span><span class="p">;</span>

	<span class="ow">in</span><span class="o">=</span><span class="n">input_plio</span><span class="p">::</span><span class="n">create</span><span class="p">(</span><span class="s2">"Datain0"</span><span class="p">,</span> <span class="n">plio_32_bits</span><span class="p">,</span>  <span class="s2">"data/input.txt"</span><span class="p">);</span>
	<span class="n">out</span><span class="o">=</span><span class="n">output_plio</span><span class="p">::</span><span class="n">create</span><span class="p">(</span><span class="s2">"Dataout0"</span><span class="p">,</span> <span class="n">plio_32_bits</span><span class="p">,</span>  <span class="s2">"data/output.txt"</span><span class="p">);</span>

    <span class="n">sp</span> <span class="o">=</span> <span class="n">adf</span><span class="p">::</span><span class="n">pktsplit</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">::</span><span class="n">create</span><span class="p">();</span>
    <span class="n">mg</span> <span class="o">=</span> <span class="n">adf</span><span class="p">::</span><span class="n">pktmerge</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">::</span><span class="n">create</span><span class="p">();</span>
    <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
    	<span class="n">adf</span><span class="p">::</span><span class="n">runtime</span><span class="o">&lt;</span><span class="n">ratio</span><span class="o">&gt;</span><span class="p">(</span><span class="n">core</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">;</span>
    	<span class="n">adf</span><span class="p">::</span><span class="n">connect</span><span class="o">&lt;</span><span class="n">adf</span><span class="p">::</span><span class="n">pktstream</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">core</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="ow">in</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="n">adf</span><span class="p">::</span><span class="n">connect</span><span class="o">&lt;</span><span class="n">adf</span><span class="p">::</span><span class="n">pktstream</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">core</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mg</span><span class="o">.</span><span class="ow">in</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="n">adf</span><span class="p">::</span><span class="n">connect</span><span class="o">&lt;</span><span class="n">adf</span><span class="p">::</span><span class="n">pktstream</span><span class="o">&gt;</span> <span class="p">(</span><span class="ow">in</span><span class="o">.</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sp</span><span class="o">.</span><span class="ow">in</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="n">adf</span><span class="p">::</span><span class="n">connect</span><span class="o">&lt;</span><span class="n">adf</span><span class="p">::</span><span class="n">pktstream</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">mg</span><span class="o">.</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out</span><span class="o">.</span><span class="ow">in</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note that the connection type for the <code class="docutils literal notranslate"><span class="pre">input_pktstream</span></code> and <code class="docutils literal notranslate"><span class="pre">output_pktstream</span></code> interfaces are <code class="docutils literal notranslate"><span class="pre">adf::pktstream</span></code>. So, it uses <code class="docutils literal notranslate"><span class="pre">adf::connect&lt;adf::pktstream&gt;</span></code> to connect the AI Engine kernel and <code class="docutils literal notranslate"><span class="pre">pktsplit.out</span></code> / <code class="docutils literal notranslate"><span class="pre">pktmerge.in</span></code>.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">input_pktstream</span></code> is read as integer input. It needs to be <code class="docutils literal notranslate"><span class="pre">reinterpret_cast</span></code> to other types if needed.</p>
<h2>Run AI Engine Simulator, HW Emulation, and HW flows</h2>
<p>Run the AI Engine simulator with the following make command.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">aiesim</span>
</pre></div>
</div>
<p>Run HW emulation with the following make command (it will build the HW system and host application) :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">run_hw_emu</span>
</pre></div>
</div>
<p>Hint: If the keyboard is accidentally hit and stops the system booting automatically, type boot at the <strong>Versal&gt;</strong> prompt to resume the system booting.</p>
<p>After Linux has booted, run the following commands at the Linux prompt (this is only for HW cosim).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mount</span> <span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">mmcblk0p1</span> <span class="o">/</span><span class="n">mnt</span>
<span class="n">cd</span> <span class="o">/</span><span class="n">mnt</span>
<span class="n">export</span> <span class="n">XILINX_XRT</span><span class="o">=/</span><span class="n">usr</span>
<span class="n">export</span> <span class="n">XCL_EMULATION_MODE</span><span class="o">=</span><span class="n">hw_emu</span>
<span class="o">./</span><span class="n">host</span><span class="o">.</span><span class="n">exe</span> <span class="n">a</span><span class="o">.</span><span class="n">xclbin</span>
</pre></div>
</div>
<p>To exit QEMU press Ctrl+A, x</p>
<p>To run in hardware, first build the system and application using the following make command.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">package</span> <span class="n">TARGET</span><span class="o">=</span><span class="n">hw</span>
</pre></div>
</div>
<p>After Linux has booted, run the following commands at the Linux prompt.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">export</span> <span class="n">XILINX_XRT</span><span class="o">=/</span><span class="n">usr</span>
<span class="n">cd</span> <span class="o">/</span><span class="n">mnt</span><span class="o">/</span><span class="n">sd</span><span class="o">-</span><span class="n">mmcblk0p1</span>
<span class="o">./</span><span class="n">host</span><span class="o">.</span><span class="n">exe</span> <span class="n">a</span><span class="o">.</span><span class="n">xclbin</span>
</pre></div>
</div>
<p>The host code is self-checking. It checks the correctness of output data. If the output data is correct, after the run has completed, it will print:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">TEST</span> <span class="n">PASSED</span>
</pre></div>
</div>
<h2>Conclusion</h2>
<p>In this tutorial you learned about:</p>
<ul class="simple">
<li><p>Building the window interface or packet stream interface to AI Engine kernels</p></li>
<li><p>Constructing the packet switching graph</p></li>
<li><p>Writing PL kernels to perform packet switching</p></li>
</ul>
<p>Licensed under the Apache License, Version 2.0 (the “License”);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">http</span><span class="p">:</span><span class="o">//</span><span class="n">www</span><span class="o">.</span><span class="n">apache</span><span class="o">.</span><span class="n">org</span><span class="o">/</span><span class="n">licenses</span><span class="o">/</span><span class="n">LICENSE</span><span class="o">-</span><span class="mf">2.0</span>
</pre></div>
</div>
<p>Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an “AS IS” BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.</p>
<p align="center"><sup>XD029 | © Copyright 2020-2021 Xilinx, Inc.</sup></p>
<footer>
<!-- Atalwar: Moved the footer code to layout.html to resolve conflict with the Xilinx template -->
</footer>
