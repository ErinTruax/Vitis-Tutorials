
<table>
<tr>
<td align="center"><img src="https://www.xilinx.com/content/dam/xilinx/imgs/press/media-kits/corporate/xilinx-logo.png" width="30%"/>
</td>
</tr>
</table>
<h2>Table of Contents</h2>
<ul class="simple">
<li><p><a class="reference external" href="#introduction">Introduction</a></p></li>
<li><p><a class="reference external" href="#before-you-begin">Before You Begin</a></p></li>
<li><p><a class="reference external" href="#system-view">System View</a></p></li>
<li><p><a class="reference external" href="#running-hardware-emulation">Running Hardware Emulation</a></p></li>
<li><p><a class="reference external" href="#references">References</a></p></li>
</ul>
<h2>Introduction</h2>
<p>The Xilinx® Versal™ adaptive compute acceleration platform (ACAP) is a fully software-programmable, heterogeneous compute platform that combines the processing system (PS) (Scalar Engines that include Arm® processors), Programmable Logic (PL) (Adaptable Engines that include the programmable logic), and AI Engines which belong in the Intelligent Engine category.</p>
<p>This tutorial shows how to use AXI Traffic Generators to provide input and capture output from an AI Engine kernel in hardware emulation.</p>
<p><strong>IMPORTANT</strong>: Before beginning the tutorial make sure you have read and followed the <em>Vitis Software Platform Release Notes</em> (v2020.2) for setting up software and installing the VCK190 base platform.</p>
<p>Before starting this tutorial Complete the following steps:</p>
<ol class="simple">
<li><p>Set up your platform by running the <code class="docutils literal notranslate"><span class="pre">xilinx-versal-common-v2021.2/environment-setup-aarch64-xilinx-linux</span></code> script as provided in the platform download. This script sets up the <code class="docutils literal notranslate"><span class="pre">SDKTARGETSYSROOT</span></code> and <code class="docutils literal notranslate"><span class="pre">CXX</span></code> variables. If the script is not present, you <strong>must</strong> run the <code class="docutils literal notranslate"><span class="pre">xilinx-versal-common-v2021.2/sdk.sh</span></code>.</p></li>
<li><p>Set up your <code class="docutils literal notranslate"><span class="pre">ROOTFS</span></code> and <code class="docutils literal notranslate"><span class="pre">IMAGE</span></code> to point to the <code class="docutils literal notranslate"><span class="pre">xilinx-versal-common-v2021.2</span></code> directory.</p></li>
<li><p>Set up your <code class="docutils literal notranslate"><span class="pre">PLATFORM_REPO_PATHS</span></code> environment variable based upon where you downloaded the platform.</p></li>
</ol>
<p>This tutorial targets the VCK190 ES board (see https://www.xilinx.com/products/boards-and-kits/vck190.html). This board is currently available via early access. If you have already purchased this board, download the necessary files from the lounge and ensure you have the correct licenses installed. If you do not have a board and ES license please contact your Xilinx sales contact.</p>
<h3>Objectives</h3>
<p>After completing the tutorial, you should be able to:</p>
<ul class="simple">
<li><p>Connect two simulation-only traffic master/slave IP cores to the AI Engine array via Vitis</p></li>
<li><p>Build and Run HW emulation (QEMU + SystemC model of AI Engine)</p></li>
<li><p>Pass data from python to the AI Engine via the simulation traffic generators</p></li>
<li><p>Configure the design for different PLIO widths</p></li>
<li><p>Capture the AI Engine output in python</p></li>
<li><p>Plot/Graph the data in python and compare against a golden reference model</p></li>
</ul>
<h3>Prerequisites</h3>
<p>To demonstrate this feature in a meaningful way you’ll also make use of a DSPLibrary function - the “Fast Fourier Transform” or FFT. The DSP Library Tutorial provides detailed instructions on how to setup your environment to compile DSPLIB. Please complete that tutorial before continuing.</p>
<ul class="simple">
<li><p>https://github.com/Xilinx/Vitis-Tutorials/tree/master/AI_Engine_Development/Feature_Tutorials/08-dsp-library</p></li>
</ul>
<h3>Tutorial Overview</h3>
<p>The following figure gives an overview of how the data will flow through this example design.</p>
<p><img alt="Alt Text" src="../../../../_images/10k_ft_overview.png"/></p>
<p>One way this flow enhances simulation coverage is by emulating the PLIO interface and the XRT Host interactions.</p>
<p>Additionally, this allows the same input data to be run through hardware emulation and a Python (or other language) model of your computation. This can be helpful for verifying correctness, understanding numerical precision, and regression testing mathematical algorithms. This tutorial will demonstrate an FFT running in the AI Engine array and compare its output to a Numpy FFT.</p>
<h3>Directory Structure</h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>traffic_generator_install
├───images        images for this README
├───aie           graph definition
│   └───kernels   individual kernels
└───sw            host XRT code
    └───pysrc     python traffic generator 
</pre></div>
</div>
<h2>Before You Begin</h2>
<h3><em>Documentation</em>: Explore AI Engine Architecture</h3>
<ul class="simple">
<li><p><a class="reference external" href="https://forums.xilinx.com/t5/Design-and-Debug-Techniques-Blog/Versal-ACAP-AI-Engines-for-Dummies/ba-p/1132493">Versal ACAP AI Engines for Dummies</a></p></li>
<li><p><a class="reference external" href="https://www.xilinx.com/support/documentation/architecture-manuals/am009-versal-ai-engine.pdf">AM009 AI Engine Architecture Manual</a></p></li>
</ul>
<h3><em>Tools</em>: Installing the Tools</h3>
<p>Tools Documentation:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.xilinx.com/member/versal_ai_tools_ea.html">AI Engine Tools lounge</a></p></li>
<li><p><a class="reference external" href="https://www.xilinx.com/member/versal_ai_core_docs_ea.html">UG1076 Versal ACAP AI Engine Programming Environment</a></p></li>
<li><p><a class="reference external" href="https://www.xilinx.com/member/versal_ai_engines.html#documentation">UG1295 Digital Signal Processing Library for AI Engine</a></p></li>
</ul>
<p>To run through this tutorial, you will need to download and install the following tools:</p>
<ul class="simple">
<li><p>Install the <a class="reference external" href="https://www.xilinx.com/support/download/index.html/content/xilinx/en/downloadNav/vitis.html">Vitis Software Platform 2021.2</a></p></li>
<li><p>Obtain licenses for the AI Engine tools</p></li>
<li><p>Download and setup the <a class="reference external" href="https://www.xilinx.com/member/versal_ai_tools_ea.html#platforms">Xilinx DSP Library (DSPLib) 2020.2</a></p></li>
<li><p>Download and setup the <a class="reference external" href="https://www.xilinx.com/member/versal_ai_tools_ea.html#platforms">VCK190 Vitis Platform for 2021.2</a></p></li>
</ul>
<h3><em>Environment</em>: Setting Up Your Target Platform Environment</h3>
<p>When the elements of the Vitis software platform are installed, update the target platform environment script.</p>
<p>Create a script file named <code class="docutils literal notranslate"><span class="pre">env_setup_2021.sh</span></code> in your favorite text editor. Replace the placeholders with the appropriate paths:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">export</span> <span class="nv">DSPLIB_ROOT</span><span class="o">=</span>&lt;YOUR-DSPLIB-DIRECTORY&gt;
<span class="nb">export</span> <span class="nv">PLATFORM_REPO_PATHS</span><span class="o">=</span>&lt;YOUR-PLATFORM-DIRECTORY&gt; 

<span class="nb">source</span> &lt;XILINX-INSTALL-LOCATION&gt;/Vitis/2021.2/settings64.sh
</pre></div>
</div>
<p>Then source the environment script:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">source</span> env_setup_2021.sh
</pre></div>
</div>
<h2><em>Validation</em>: Confirming Tool Installation</h2>
<p>Ensure that you are using the 2021.2 version of Xilinx tools.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>which vitis
which aiecompiler
<span class="nb">echo</span> <span class="nv">$DSPLIB_ROOT</span>
</pre></div>
</div>
<h3><em>Validation</em>: Python Environment</h3>
<p>A python 3.6 or newer environment is required for this tutorial. Struct, numpy, and matplotlib packages are also required. To confirm they are installed open a terminal and type this command.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>python3 -c <span class="s1">'import numpy, matplotlib, struct'</span>
</pre></div>
</div>
<p>If this returns without error, you have the libraries required to proceed.</p>
<h3><em>Other Tutorials</em>: Learn Basic Vitis Compiler and AI Engine Concepts</h3>
<p>For novice users, following link provides tutorials to understand the basic Vitis compiler concepts and building simple AI Engine designs:</p>
<ul class="simple">
<li><p>https://github.com/Xilinx/Vitis-Tutorials</p></li>
</ul>
<h2>System View</h2>
<p><img alt="Alt Text" src="../../../../_images/v777_sysOverview.png"/></p>
<p>In the previous figure the AXIS traffic generator provides a path to the AI Engine input via a sim_ipc IP core. You will see this IP core on the BD in a later step. The AI Engine array has multiple AXI streaming inputs but for this tutorial you will use just one. Different application requirements such as precision and throughput will use different data types and PLIO widths. For example the cint16 datatype often maximizes AI Engine compute capabilities while floating point datatypes provide the most dynamic range. The traffic generator XO files see all data as byte arrays of different widths based on the PLIO width and the corresponding XO file linked with <code class="docutils literal notranslate"><span class="pre">v++</span></code>. For this tutorial you will send an array of complex 16-bit integers into the AI Engine array and perform a Fast Fourier Transform (FFT) using the DSP Library for AI Engine.</p>
<h3>Connecting the AXI Traffic XOs</h3>
<p><img alt="Alt Text" src="../../../../_images/v777_tgen_picture.png"/></p>
<ol>
<li><p>To integrate the appropriate sim_ipc_axis you need to tell the linker how you want to connect them together. These connections are described in a configuration file: <code class="docutils literal notranslate"><span class="pre">system.cfg</span></code> in this tutorial.</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[connectivity]</span>
<span class="na">nk</span><span class="o">=</span><span class="s">sim_ipc_axis_master:1:tx_iqdata</span>
<span class="na">nk</span><span class="o">=</span><span class="s">sim_ipc_axis_slave:1:rx_iqdata</span>
<span class="na">stream_connect</span><span class="o">=</span><span class="s">tx_iqdata.M00_AXIS:ai_engine_0.DataIn</span>
<span class="na">stream_connect</span><span class="o">=</span><span class="s">ai_engine_0.DataOut:rx_iqdata.S00_AXIS</span>
</pre></div>
</div>
</li>
<li><p>Link the XO files using the <code class="docutils literal notranslate"><span class="pre">v++</span></code> link command. The makefile handles this by bringing in the correct width of XO based on the PLIO_WIDTH makefile command.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>PLIO_WIDTH :<span class="o">=</span> <span class="m">64</span>
KERNEL_XO :<span class="o">=</span> pl_kernels/sim_ipc_axis_master_<span class="si">${</span><span class="nv">PLIO_WIDTH</span><span class="si">}</span>.xo pl_kernels/sim_ipc_axis_slave_<span class="si">${</span><span class="nv">PLIO_WIDTH</span><span class="si">}</span>.xo
...
VPP_LINK_FLAGS :<span class="o">=</span> -l --platform <span class="k">$(</span>BASE_PLATFORM<span class="k">)</span> <span class="k">$(</span>KERNEL_XO<span class="k">)</span> <span class="k">$(</span>GRAPH_O<span class="k">)</span> -t <span class="k">$(</span>TARGET<span class="k">)</span> --save-temps -g --config <span class="k">$(</span>CONFIG_FILE<span class="k">)</span> -o <span class="k">$(</span>PFM<span class="k">)</span>.xclbin
</pre></div>
</div>
</li>
</ol>
<h3>Understanding the Python</h3>
<p>The following diagram illustrates the connections between the several steps required to interact with the traffic generators.</p>
<ol class="simple">
<li><p>For this tutorial the user data generator will be a complex sine wave.</p></li>
<li><p>You will convert it to a byte array</p></li>
<li><p>Handle the AXI transactions</p></li>
<li><p>Pass the data to the XTLM python</p>
<ol class="simple">
<li><p>XTLM will pass data to the AIE array</p></li>
<li><p>XTLM AXIS Slave will capture the output data</p></li>
<li><p>Capture the data in the rx_from_aie thread()</p></li>
<li><p>Pass the data to the parent thread via a pipe</p></li>
</ol>
</li>
<li><p>Convert to byte to array numpy</p></li>
<li><p>Plot the data</p></li>
</ol>
<p><img alt="Alt Text" src="../../../../_images/v777_python_threading.png"/></p>
<p>Regardless of the PLIO width the AXI Traffic Master and Slave both operate on a python bytes-like object. Numpy arrays can be either real or complex valued and have a convenient built-in method called “tobytes()” that makes interacting with the ipc_axis_master_util/slave_util very straightforward.</p>
<h4>Creating a Sine Wave Data Vector</h4>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Nsamps</span><span class="p">)</span>
<span class="n">Fs</span> <span class="o">=</span> <span class="mf">245.76e6</span>
<span class="n">ft</span> <span class="o">=</span> <span class="mf">30.72e6</span><span class="o">/</span><span class="mi">16</span>
<span class="n">cplxt</span> <span class="o">=</span>  <span class="mf">1.0</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">ft</span><span class="o">/</span><span class="n">Fs</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>

<span class="n">Nbits</span> <span class="o">=</span>  <span class="mi">16</span>    
<span class="c1">#Quantize to NBits</span>
<span class="n">mx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cplxt</span><span class="p">))</span>
<span class="n">cscaled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">cplxt</span><span class="o">/</span><span class="n">mx</span>  <span class="o">*</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">Nbits</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="k">return</span> <span class="n">cscaled</span>
</pre></div>
</div>
<h4>Convert Numpy to Byte Array</h4>
<p>Following is an example of python code showing the axis_master side for cint16 data types.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">#Convert numpy complex vector into two columns of int16s </span>
<span class="n">rVec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span> 
<span class="n">iVec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>

<span class="n">out2column</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">L</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span> 
<span class="n">out2column</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">rVec</span>
<span class="n">out2column</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">iVec</span>

<span class="c1">#Convert numpy 2d array into bytes</span>
<span class="n">payload</span> <span class="o">=</span> <span class="n">out2column</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span>
<span class="c1">#Send the bytes to the AXI Traffic Generator </span>
<span class="n">b_transport</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
</pre></div>
</div>
<p>See the provided python file for examples of floats and cfloat data types.</p>
<h4>Generate AXI Transactions</h4>
<p>Next you will examine the AXI Streaming transactions required to interact with the traffic generators. The provided python script performs these steps for you if you would like to provide only a numpy array. Having a better understanding of the underlying transactions can be helpful and that is what will be explained in detail now.</p>
<p>In the code snippet below on lines 1 to 5 the byte array to be sent needs to be broken into pieces equal to the width of the PLIO interface. Because the PLIO interface width is commonly identified with units of bits (PLIO32/64/128 are 32, 64, and 128 bits wide) the width of the transaction in bytes is divided by 8.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="mi">1</span> <span class="c1">#Determine number of transactions based on</span>
    <span class="mi">2</span> <span class="c1">## packet length and PLIO WIDTH</span>
    <span class="mi">3</span> <span class="n">NumBytesToSend</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">iq_data_as_bytes</span><span class="p">)</span>
    <span class="mi">4</span> <span class="n">NumBytesPerBeat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plio_width</span><span class="o">//</span><span class="mi">8</span>
    <span class="mi">5</span> <span class="n">NumTrans</span> <span class="o">=</span> <span class="n">NumBytesToSend</span><span class="o">//</span><span class="n">NumBytesPerBeat</span>
</pre></div>
</div>
<p>On line 5 you see that by dividing the PLIO width in bytes by the total number of bytes you can compute how many “TVALID” transactions.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="mi">7</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NumTrans</span><span class="p">):</span>
    <span class="mi">8</span>     
    <span class="mi">9</span>     <span class="n">payload</span> <span class="o">=</span> <span class="n">xtlm_ipc</span><span class="o">.</span><span class="n">axi_stream_packet</span><span class="p">()</span>    
    <span class="mi">10</span> 
    <span class="mi">11</span>     <span class="n">data2send</span> <span class="o">=</span> <span class="n">iq_data_as_bytes</span><span class="p">[(</span><span class="n">i</span><span class="o">*</span><span class="n">NumBytesPerBeat</span><span class="p">):(</span><span class="n">i</span><span class="o">*</span><span class="n">NumBytesPerBeat</span><span class="p">)</span><span class="o">+</span><span class="n">NumBytesPerBeat</span><span class="p">]</span>
    <span class="mi">12</span>     <span class="c1">#Grab a "chunk" of the byte array of size PLIO</span>
    <span class="mi">13</span> 
    <span class="mi">14</span>     <span class="n">payload</span><span class="o">.</span><span class="n">data_length</span> <span class="o">=</span> <span class="n">NumBytesPerBeat</span>
    <span class="mi">15</span>     <span class="n">payload</span><span class="o">.</span><span class="n">data</span>  <span class="o">=</span><span class="n">data2send</span>
</pre></div>
</div>
<p>Here you see lines 7-15 containing a for loop construction. Each iteration of the loop creates an axi_stream packet object and populates all of its elements. The data is broken into appropriately sized chunks of NumBytesPerBeat.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="mi">19</span>     <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">NumTrans</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="mi">20</span>         <span class="n">payload</span><span class="o">.</span><span class="n">tlast</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="mi">21</span>     <span class="k">else</span><span class="p">:</span>
    <span class="mi">22</span>         <span class="n">payload</span><span class="o">.</span><span class="n">tlast</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="mi">23</span>         
    <span class="mi">24</span> 
    <span class="mi">25</span>     <span class="bp">self</span><span class="o">.</span><span class="n">in0_util</span><span class="o">.</span><span class="n">b_transport</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, lines 19-25 contain the handling of the TLast as well as the actual transmission of the full payload object using the <code class="docutils literal notranslate"><span class="pre">b_transport()</span></code> method.</p>
<!-- 
[//]: #Lines 17-22
[//]: #For each transaction of PLIOWIDTH a single bit representing a byte-enable flag must be set. For PLIO32, which is 4 bytes, those 4 enable flags can be encoded as 0b1111 or 0xF. Similarly, PLIO64 is 0xFF and PLIO128 is 0xFFFF.
 --><p>For more information see: <a class="reference external" href="https://www.xilinx.com/support/documentation/ip_documentation/ug761_axi_reference_guide.pdf">UG761 AXI Reference Guide</a>.</p>
<h4>Receive AI Engine Array Output</h4>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">#Receive byte array from AXI traffic generator slave</span>
<span class="n">payload</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">out0_util</span><span class="o">.</span><span class="n">sample_transaction</span><span class="p">()</span>
<span class="c1">#Note: this is a blocking call</span>

<span class="n">formatString</span> <span class="o">=</span> <span class="s2">"&lt;"</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="s2">"h"</span>
<span class="c1">#"h" corresponds to a signed short which is 2 bytes in size. len() returns units of bytes.</span>

<span class="n">upack</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">formatString</span><span class="p">,</span> <span class="n">payload</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

<span class="c1">#take the even numbered samples for real</span>
<span class="n">rvec</span> <span class="o">=</span> <span class="n">upack</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">upack</span><span class="p">):</span><span class="mi">2</span><span class="p">]</span>
<span class="c1">#take the odd numbered samples for imaginary</span>
<span class="n">ivec</span> <span class="o">=</span> <span class="n">upack</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">upack</span><span class="p">):</span><span class="mi">2</span><span class="p">]</span>

<span class="c1">#Reassemble into a complex numpy array</span>
<span class="n">cVec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rvec</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ivec</span><span class="p">)</span>
</pre></div>
</div>
<h4>Convert Byte Array to Numpy</h4>
<p>This section briefly covers how to capture data from the AI Engine array. For full details please see the python function <code class="docutils literal notranslate"><span class="pre">convert_bytes_to_numpy()</span></code>. The <code class="docutils literal notranslate"><span class="pre">sample_transaction()</span></code> method blocks and returns a full AXI payload consisting of all the data received from the AI Engine array. This is different than the transmitting AXI side because the data is captured as an array of bytes with TLAST forming the packet boundary. The format string variable is important for interpreting the byte array appropriately. For this tutorial a cint16 window type was used as the output. The <code class="docutils literal notranslate"><span class="pre">unpack()</span></code> method interprets the output as an array of int16s (2 bytes each) and then takes the even samples to form the real and imaginary components of the complex vector. These are packed into a single complex data vector.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">#Receive byte array from AXI traffic generator slave</span>
<span class="n">payload</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">out0_util</span><span class="o">.</span><span class="n">sample_transaction</span><span class="p">()</span>
<span class="c1">#Note: this is a blocking call</span>

<span class="n">formatString</span> <span class="o">=</span> <span class="s2">"&lt;"</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="s2">"h"</span>
<span class="c1">#"h" corresponds to a signed short which is 2 bytes in size. len() returns units of bytes.</span>

<span class="n">upack</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">formatString</span><span class="p">,</span> <span class="n">payload</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

<span class="c1">#take the even numbered samples for real</span>
<span class="n">rvec</span> <span class="o">=</span> <span class="n">upack</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">upack</span><span class="p">):</span><span class="mi">2</span><span class="p">]</span>
<span class="c1">#take the odd numbered samples for imaginary</span>
<span class="n">ivec</span> <span class="o">=</span> <span class="n">upack</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">upack</span><span class="p">):</span><span class="mi">2</span><span class="p">]</span>

<span class="c1">#Reassemble into a complex numpy array</span>
<span class="n">cVec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rvec</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ivec</span><span class="p">)</span>
</pre></div>
</div>
<h4>Plot the results</h4>
<p>Matplotlib is a helpful python library that mimics other plotting tools. In this tutorial the traffic generator output data will be plotted or saved as a PNG image. A visual inspection can be helpful for iterative debugging prior to developing self-checking test benches or golden data vectors.</p>
<p>The python function “plot results” displays several graphs of the output data with different colors defined in a legend.</p>
<p>See www.matplotlib.org for more information on Matplotlib’s features.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">aie_out</span><span class="p">))),</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">aie_out</span><span class="p">),</span><span class="n">label</span> <span class="o">=</span><span class="s2">"aie_out R"</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">aie_out</span><span class="p">))),</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">aie_out</span><span class="p">),</span><span class="n">label</span>  <span class="o">=</span><span class="s2">"aie_out I "</span><span class="p">)</span>   
</pre></div>
</div>
<h2>Running Hardware Emulation</h2>
<h3>AI Engine and Versal Integration</h3>
<p>The process of linking XO files via <code class="docutils literal notranslate"><span class="pre">v++</span></code> and the <code class="docutils literal notranslate"><span class="pre">system.cfg</span></code> is covered in depth in the following two tutorials. For this tutorial these steps are handled by the provided makefile and you will review only the highlights.</p>
<p>https://github.com/Xilinx/Vitis-Tutorials/tree/master/AI_Engine_Development/Feature_Tutorials/05-AI-engine-versal-integration</p>
<p>https://github.com/Xilinx/Vitis-Tutorials/tree/master/AI_Engine_Development/Design_Tutorials/03-beamforming/Module_04_AI_Engine_and_PL_Integration</p>
<h3>Section 1: Compile XO Files and AI Engine Graph</h3>
<p>The first step is to take any v++ kernels (HLS C) and your AI Engine kernels and graph and compile them into their respective <code class="docutils literal notranslate"><span class="pre">.xo</span></code> and <code class="docutils literal notranslate"><span class="pre">.o</span></code> files. You can compile the kernels and graph in parallel because they do not rely on each other at this stage.</p>
<h4>Compiling the XO Files Using v++</h4>
<p>To compile the <code class="docutils literal notranslate"><span class="pre">sim_ipc_axis_master</span></code> and <code class="docutils literal notranslate"><span class="pre">sim_ipc_axis_slave</span></code> files, use the <code class="docutils literal notranslate"><span class="pre">v++</span></code> compiler command - which takes in an HLS kernel source and produces an <code class="docutils literal notranslate"><span class="pre">.xo</span></code> file.</p>
<p>To compile the kernels, run the following command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make kernels
</pre></div>
</div>
<p>This won’t take for long for this tutorial.</p>
<h4>Compiling an AI Engine ADF Graph for V++ Flow</h4>
<p>An ADF Graph can be connected to an extensible Vitis platform. That is, the graph I/Os can be connected either to platform ports or to ports on Vitis kernels through the <code class="docutils literal notranslate"><span class="pre">v++</span></code> connectivity directives. Note the following:</p>
<ul class="simple">
<li><p>An AI Engine ADF C++ graph contains AI Engine kernels only.</p></li>
<li><p>All interconnections between AI Engine kernels are defined in the C++ graph (<code class="docutils literal notranslate"><span class="pre">graph.h</span></code>).</p></li>
<li><p>All interconnections to external I/Os are fully specified in the C++ simulation testbench (<code class="docutils literal notranslate"><span class="pre">graph.cpp</span></code>) that instantiates the C++ ADF graph object (this is strictly only used in <code class="docutils literal notranslate"><span class="pre">aiesimulator</span></code> which is covered in a separate tutorial). All platform connections from the graph to the “PLIO” map onto ports on the AI Engine subsystem graph that are connected via v++ connectivity directives.</p></li>
<li><p>No dangling ports or implicit “connections” are allowed by <code class="docutils literal notranslate"><span class="pre">v++</span></code>.</p></li>
<li><p>Stream connections are specified through the <code class="docutils literal notranslate"><span class="pre">v++</span> <span class="pre">--sc</span></code> option, including employment of PL-based data movers, either in the platform or defined outside the ADF graph as Vitis PL kernels.</p></li>
</ul>
<p>To compile the graph type to be used in hardware emulation, use:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make aie
</pre></div>
</div>
<p>This may take a few minutes.</p>
<h4>Connecting the traffic generators with V++</h4>
<p><code class="docutils literal notranslate"><span class="pre">v++</span></code> lets you integrate your AI Engine, HLS, and RTL kernels into an existing extensible platform. This step is where the platform chosen is provided by the hardware designer (or you can opt to use one of the many extensible base platforms provided by Xilinx) and <code class="docutils literal notranslate"><span class="pre">v++</span></code> builds the hardware design for you in addition to integrating the AI Engine and PL kernels in the design.</p>
<p>You have a number of kernels at your disposal, but you need to tell the linker how you want to connect them together (from the AI Engine array to PL and vice versa). These connections are described in a configuration file: <code class="docutils literal notranslate"><span class="pre">system.cfg</span></code> in this tutorial.</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[connectivity]</span>
<span class="na">nk</span><span class="o">=</span><span class="s">sim_ipc_axis_master:1:tx_iqdata</span>
<span class="na">nk</span><span class="o">=</span><span class="s">sim_ipc_axis_slave:1:rx_iqdata</span>
<span class="na">stream_connect</span><span class="o">=</span><span class="s">tx_iqdata.M00_AXIS:ai_engine_0.DataIn</span>
<span class="na">stream_connect</span><span class="o">=</span><span class="s">ai_engine_0.DataOut:rx_iqdata.S00_AXIS</span>
</pre></div>
</div>
<p>If additional master and slave traffic generator interfaces are required, change the “1” (between the sim_ipc_axis and the instance name) instead of instantiating more new kernels with the <code class="docutils literal notranslate"><span class="pre">nk</span></code> command.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">ai_engine_0</span></code> the names are provided in the <code class="docutils literal notranslate"><span class="pre">graph.cpp</span></code> when instantiating a <code class="docutils literal notranslate"><span class="pre">PLIO</span></code> object. For this design, as an example, this line <code class="docutils literal notranslate"><span class="pre">PLIO</span> <span class="pre">*in0</span> <span class="pre">=</span> <span class="pre">new</span> <span class="pre">PLIO("DataIn1",</span> <span class="pre">adf::plio_32_bits,"data/input.txt");</span></code> has the name <strong>DataIn1</strong> which is the interface name.</p>
<p>You can see the <code class="docutils literal notranslate"><span class="pre">v++</span></code> switches in more detail in the <a class="reference external" href="https://www.xilinx.com/support/documentation/sw_manuals/xilinx2021.2/ug1393-vitis-application-acceleration.pdf">Vitis Unified Software Platform Documentation</a>.</p>
<p>To build the design, run the following command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make xclbin
</pre></div>
</div>
<p>This will likely take more than 5 or 10 minutes.</p>
<h3>Section 3: Compile the A72 Host Application</h3>
<p>After all the new AI Engine outputs are created, you can compile your host application by following the typical cross-compilation flow for the Cortex-A72. As you might notice, the host code is using <a class="reference external" href="http://www.github.com/Xilinx/XRT">XRT</a> (Xilinx Run Time) as an API to talk to the AI Engine and PL kernels. Notice that in the linker that it is using the the libraries: <code class="docutils literal notranslate"><span class="pre">-ladf_api_xrt</span> <span class="pre">-lxrt_coreutil</span></code>.</p>
<ol>
<li><p>Open <code class="docutils literal notranslate"><span class="pre">sw/main.cpp</span></code> and familiarize yourself with the contents. A benefit of the AXI Traffic Generators is the host code required is quite simple.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>mygraph_float&lt;WIN_SAMPS&gt;  graph_top<span class="p">;</span>
graph_top.init<span class="o">()</span><span class="p">;</span>
graph_top.run<span class="o">(</span><span class="m">1</span><span class="o">)</span><span class="p">;</span>
graph_top.end<span class="o">()</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that <a class="reference external" href="https://xilinx.github.io/XRT/2021.2/html/index.html">XRT</a> is used in the host application. This API layer is used to communicate with the programmable logic, specifically the PLIO kernels for reading and writing data. To understand how to use this API in an AI Engine application refer to the “Programming the PS Host Application”.</p>
</li>
<li><p>Close the main.cpp, and run the command.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make host
</pre></div>
</div>
</li>
</ol>
<p>This won’t take very long.</p>
<h3>Section 4: Package the Design</h3>
<p>With all the AI Engine outputs and the new platform created, you can now generate the Programmable Device Image (PDI) and a package to be used in the hardware emulated SD card. The PDI contains all executables, bitstreams, and configurations of every element of the device, and the packaged SD card directory contains everything to boot Linux and have your generated application and <code class="docutils literal notranslate"><span class="pre">.xclbin</span></code>.</p>
<p>To package the design, run the following command.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make package
</pre></div>
</div>
<h3>Section 5: Run Hardware Emulation</h3>
<p>After packaging, everything is set to run emulation or hardware.</p>
<ol>
<li><p>To run emulation use the following command.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make run_emu
</pre></div>
</div>
<p>Or</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span> ./sw
./launch_hw_emu.sh
<span class="nb">cd</span> ..
</pre></div>
</div>
<p>This will take between 5 and 10 minutes to fully launch QEMU.</p>
<p>When launched, use the Linux prompt presented to run the design.</p>
</li>
<li><p>Execute the following command when the emulated Linux prompt displays:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span> /mnt/sd-mmcblk0p1
<span class="nb">export</span> <span class="nv">XILINX_XRT</span><span class="o">=</span>/usr
</pre></div>
</div>
<p>This will set up the design to run emulation. Run the design using the following command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./host.exe a.xclbin
</pre></div>
</div>
<p>The host and graph are now running waiting for input from the traffic generators. Your QEMU terminal should look as follows:</p>
<p><img alt="Alt Text" src="../../../../_images/v777_qemu_wait.png"/></p>
</li>
<li><p>In a new terminal execute <code class="docutils literal notranslate"><span class="pre">run_traffic_generators.py</span></code> with the following command.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make run_tgen
</pre></div>
</div>
<p>In the makefile run_tgen task simply executes the python script.</p>
<p>For 128 samples (the default amount for this tutorial) - this step will take 1 or 2 minutes to run.</p>
<p>The default settings for this tutorial is only 128 samples which will execute in the hardware emulation environment quite quickly. A matplotlib window will appear that looks as follows:</p>
<p><img alt="Alt Text" src="../../../../_images/V777_tutorial_fftout.png"/></p>
<p>As you can see in the figure, the output of the DSPLib FFT module matches the expected output.</p>
<p>When this is shown, run the keyboard command: <code class="docutils literal notranslate"><span class="pre">Ctrl+A</span> <span class="pre">x</span></code> to end the QEMU instance.</p>
</li>
</ol>
<p><strong>IMPORTANT</strong>: To rerun the application you need to restart QEMU from scratch.</p>
<h3>Summary</h3>
<p>In this tutorial you learned how to:</p>
<ul class="simple">
<li><p>Connect two simulation-only traffic master/slave IP cores to the AI Engine array via Vitis</p></li>
<li><p>Build and Run HW emulation (QEMU + SystemC model of AI Engine)</p></li>
<li><p>Pass data from python to the AI Engine via the simulation traffic generators.</p></li>
<li><p>Configure the design for different PLIO widths</p></li>
<li><p>Capture the AI Engine output in python</p></li>
<li><p>Plot/Graph the data in python and compare against a golden reference model</p></li>
</ul>
<p>To read more about the use of Vitis in the AI Engine flow see: <em>UG1076: Versal ACAP AI Engine Programming Environment Chapter 13: Running Hardware Emulation &amp; Traffic Generators</em>.</p>
<h4>Support</h4>
<p>GitHub issues will be used for tracking requests and bugs. For questions go to <a class="reference external" href="http://forums.xilinx.com/">forums.xilinx.com</a>.</p>
<h4>License</h4>
<p>Licensed under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License.</p>
<p>You may obtain a copy of the License at <a class="reference external" href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p align="center"><sup>XD066 | © Copyright 2021 Xilinx, Inc.</sup></p>
<footer>
<!-- Atalwar: Moved the footer code to layout.html to resolve conflict with the Xilinx template -->
</footer>
